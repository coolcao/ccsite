---
title: 「垃圾回收的算法与实现-分代垃圾回收」.md
date: 2021-07-20 09:43:01
tags: [垃圾回收, GC, 分代垃圾回收]
categories:
- 技术博客
- 原创
---

分代垃圾回收(Generational GC)在对象中导入了“年龄”的概念，通过优先回收容易成为垃圾的对象，提高垃圾回收的效率。

## 什么是分代垃圾回收

### 对象的年龄

一个经验：**大部分的对象在生成后马上就变成了垃圾， 很少有对象能活得很久。**
分代垃圾回收利用这个经验，在对象中导入年龄的概念，通过优先回收容易成为垃圾的对象，提高垃圾回收的效率。

### 新生代对象和老年代对象

分代垃圾回收中把对象分类成几代，针对不同的代使用不同的 GC 算法，我们把刚生成的对象称为 `新生代对象`，到达一定年龄的对象则称为 `老年代对象`。

我们将对新对象执行的 GC 称为新生代 GC(minor GC)。minor 在这里的意思是“小规模的”。 新生代 GC 的前提是大部分新生代对象都没存活下来，GC 在短时间内就结束了。

另一方面，新生代 GC 将存活了一定次数的新生代对象当作老年代对象来处理。我们把类似于这样的新生代对象上升为老年代对象的情况称为 **`晋升`**(promotion)。

因为老年代对象很难成为垃圾，所以我们对老年代对象减少执行 GC 的频率。相对于新生代 GC，我们将面向老年代对象的 GC 称为老年代 GC(major GC)。

> 在这里有一点需要注意，那就是分代垃圾回收不能单独用来执行 GC。我们需要把它和之前介绍的基本算法结合在一起使用，来提高那些基本算法的效率。

## Ungar 的分代垃圾回收

### 堆的结构
在 Ungar 的分代垃圾回收中，堆的结构如图所示。

![](https://img-vnote-1251075307.cos.ap-beijing.myqcloud.com/1626750458_20210720094950736_1616285012.png)

我们总共需要利用 4 个空间，分别是 `生成空间`、2 个大小相等的 `幸存空间`以及 `老年代空间`，并分别用 `$new_start`、`$survivor1_start`、`$survivor2_start`、`$old_start` 这 4 个变量引用它们的开头。
我们将生成空间和幸存空间合称为新生代空间。新生代对象会被分配到新生代空间，老年代对象则会被分配到老年代空间里。

此外我们准备出一个和堆不同的数组，称为记录集(remembered set)，设为 `$rs`。

生成空间是生成对象的空间，也就是进行分配的空间。当生成空间满了的时候，新生代 GC 就会启动，将生成空间中的所有活动对象复制，这跟 GC 复制算法是一个道理。目标空间是幸存空间。

2 个幸存空间和 GC 复制算法里的 From 空间、To 空间很像，我们经常只利用其中的一个。 在每次执行新生代 GC 的时候，活动对象就会被复制到另一个幸存空间里。在此我们将正在 使用的幸存空间作为 From 幸存空间，将没有使用的幸存空间作为 To 幸存空间。

不过新生代 GC 也必须复制生成空间里的对象。也就是说，生成空间和 From 幸存空间 这两个空间里的活动对象都会被复制到 To 幸存空间里去。这就是新生代 GC。

只有从一定次数的新生代 GC 中存活下来的对象才会得到晋升，也就是会被复制到老年代空间去。

![](https://img-vnote-1251075307.cos.ap-beijing.myqcloud.com/1626750458_20210720095233473_1381545781.png)

在执行新生代 GC 时有一点需要注意，那就是我们必须考虑到从老年代空间到新生代空间的引用。新生代对象不只会被根和新生代空间引用，也可能被老年代对象引用。因此，除了一般 GC 里的根，我们还需要将从老年代空间的引用当作根(像根一样的东西)来处理。

![](https://img-vnote-1251075307.cos.ap-beijing.myqcloud.com/1626750459_20210720095310539_1046749903.png)

记录集用来记录从老年代对象到新生代对象的引用。这样在新生代 GC 时就可以不搜索老年代空间的所有对象，只通过搜索记录集来发现从老年代对象到新生代对象的引用。

### 记录集

在记录集里不会记录引用的目标对象，而是记录发出引用的对象。这样一来，我们就能通过记录集搜索发出引用的对象，进而晋升引用的目标对象，再将发出引用的对象的 指针更新到目标空间了。

![](https://img-vnote-1251075307.cos.ap-beijing.myqcloud.com/1626750459_20210720095455518_539583497.png)

记录集基本上是用固定大小的数组来实现的。各个元素是指向对象的指针。

### 写入屏障

在分代垃圾回收中，为了将老年代对象记录到记录集里，我们利用写入屏障(write barrier)。 在 mutator 更新对象间的指针的操作中，写入屏障是不可或缺的。

```c
write_barrier(obj, field, new_obj) {
    if (obj >= $old_start && new_obj < $old_start && obj.remembered == FALSE) {
        $rs[$rs_index] = obj
        $rs_index++
        obj.remembered = TRUE
    }

    *field = new_obj
}
```

参数 obj 是发出引用的对象，obj 内存在要更新的指针，而 field 指的就是 obj 内的域， new_obj 是在指针更新后成为引用目标的对象。

在第 2 行中检查以下 3 点。

- 发出引用的对象是不是老年代对象
- 指针更新后的引用的目标对象是不是新生代对象 
- 发出引用的对象是否还没有被记录到记录集中

当这些检查结果都为真时，obj 就被记录到记录集中了。

### 对象的结构

在 Ungar 的分代垃圾回收中，对象的头部中除了包含对象的种类和大小之外，还有以下这 3 条信息。

- 对象的年龄(age)
- 已经复制完毕的标志(forwarded)
- 已经向记录集记录完毕的标志(remembered)

![](https://img-vnote-1251075307.cos.ap-beijing.myqcloud.com/1626750460_20210720095943393_2103876445.png)

### 分配
分配是在生成空间进行的。

```c
new_obj(size) {
    // 检查生成空间中是否存在 size 大小的分块。如果没有足够大小的分块， 就执行新生代 GC
    if ($new_free + size >= $survivor1_start) {
        minor_gc()
        // GC一次后，还是没有足够大的分块，分配失败
        if ($new_free + size >= survivor1_start) {
            allocation_fail()
        }
    }

    obj = $new_free
    $new_free += size

    obj.age = 0
    obj.forwarded = FALSE
    obj.remembered = FALSE
    obj.size = size

    return obj
}
```

### 新生代GC

生成空间被对象占满后，新生代 GC 就会启动，执行这项操作的是 minor_gc() 函数。 minor_gc() 函数负责把新生代空间中的活动对象复制到 To 幸存空间和老年代空间。

```c
copy(obj) {
    if (obj.forwarded == FALSE) {
        if (obj.age < AGE_MAX) {
            copy_data($to_survivor_free, obj, obj.size)

            obj.forwarded = TRUE
            obj.forwarding = $to_survivor_free

            $to_survivor_free.age++
            $to_survivor_free += obj.size
            for (child: children(obj)) {
                *child = copy(*child)
            }
        } else {
            promote(obj)
        }
    }

    return obj.forwarding
}

promote(obj) {
    new_obj = allocate_old(obj)
    // 如果在老年代空间无法分配，则启动老年代GC
    if (new_obj == NULL) {
        major_gc()
        new_obj = allocate_in_old(obj)
        if (new_obj == NULL) {
            allocation_fail()
        }
    }
    // 修改指针
    obj.forwarding = new_obj
    obj.forwarded = TRUE

    for(child: children(new_obj)) {
        if (*child < $old_start) {
            // 记录到记录集
            $rs[$rs_index] = new_obj
            $rs_index++
            new_obj.remembered = TRUE
            return
        }
    }
}
```

晋升可以看成是一项把对象分配到老年代空间的操作，不过在这里被分配的对象是“新生代空间中年龄达到了 AGE_MAX 的对象”。在 promote() 函数中，参数 obj 是需要晋升的对象。

```c
minor_gc() {
    //分配 To 幸存空间的分块
    $to_survivor_free = $to_survivor_start
    // 复制能从根找到的新生代对象
    for (r:$roots) {
        if (*r < $old_start) {
            *r = copy(*r)
        }
    }
    i = 0
    // 搜索记录集中记录的对象 $rs[i]，执行子对象的复制操作
    // 这是为了复制从老年代对象引用的新生代对象而执行的操作
    while(i < $rs_index) {
        has_new_obj = FALSE
        for(child: children(rs[i])) {
            if (*child < $old_start) {
                *child = copy(*child)
                // 检查复制后的对象是还在新生代空间，还是已经晋升到老年代空间里去了
                // 复制后的对象如果还在新生代空间，就要把已经设定为 FALSE 的 has_new_obj 标志设定为 TRUE
                if (*child < $old_start) {
                    has_new_obj = TRUE
                }
            }
        }
        // 如果标志为 FALSE，则老年代对象 $rs[i] 就已经没有指向新生代空间的引用了
        if (has_new_obj == FALSE) {
            // 这种情况下，我们将这个元素从记录集里删除
            $rs[i].remembered = FALSE
            $rs_index++
            swap($rs[i], $rs[$rs_index])
        } else {
            i++
        }
    }
    // 将 From 幸存空间和 To 幸存空间互换，新生代 GC 就结束了
    swap($from_survivor_start, $to_survivor_start)
}
```

![](https://img-vnote-1251075307.cos.ap-beijing.myqcloud.com/1626750460_20210720103531887_1533163260.png)

> ### 幸存空间满了怎么办?
> 通常的 GC 复制算法把空间二等分为 From 空间和 To 空间，即使 From 空间里的对象都还活着，也确保能把它们收纳到 To 空间里去。不过在 Ungar 的分代垃圾回收里，To 幸存空间必须收纳 From 幸存空间以及生成空间中的活动对象。From 幸存空间和生存空间的点大小比 To 幸存空间大，所以如果活动对象很多，To 幸存空间就无法容纳下它们。
> 当发生这种情况时，稳妥起见只能把老年代空间作为复制的目标空间。当然，如果频繁发生这种情况，分代垃圾回收的优点就会淡化。
> 然而实际上经历晋升的对象很少，所以这不会有什么重大问题，因此在伪代码中我们就把这 步操作省略掉了。

### 老年代 GC
Ungar 的论文里在老年代 GC 中用到了 `标记-清除算法`。

## 优点
### 吞吐量得到改善
很多对象年纪轻轻就会死”这一法则虽然是经验之谈，不过还是适用于大多数情况的。 以这个法则为前提，新生代 GC 只将刚生成的对象当成对象，这样一来就能减少时间上的消耗。

反过来，因为老年代 GC 是针对很难变成垃圾的老年代对象执行的，所以要比新生代 GC 花的时间长。不过，在经过新生代 GC 而晋升的对象把老年代空间填满之前，老年代 GC 都不会被执行。因此，老年代 GC 的执行频率要比新生代 GC 低。

综合来看，通过使用分代垃圾回收，可以改善 GC 所花费的时间(吞吐量)。正如 Ungar 所说的那样:“据实验表明，分代垃圾回收花费的时间是 GC 复制算法的 1/4。”可见分代垃圾 回收的导入非常明显地改善了吞吐量。

另一方面，因为老年代 GC 很费时间，所以我们没法缩短 mutator 的最大暂停时间。

## 缺点
### 在部分程序中会起到反作用
“很多对象年纪轻轻就会死”这个法则毕竟只适合大多数情况，并不适用于所有程序。当然， 对象会活得很久的程序也有很多。对这样的程序执行分代垃圾回收，就会产生以下两个问题。

- 新生代GC所花费的时间增多 
- 老年代GC频繁运行

考虑到这两点，恐怕我们没法利用到分代垃圾回收的优点，或者就算利用到了，效果也 甚微。

而且，写入屏障导致的额外负担降低了吞吐量。只有当新生代 GC 带来的速度提升效果大于写入屏障对速度造成的影响时，分代垃圾回收才能够更好地发挥作用。当这个大小关系不成立时，分代垃圾回收就没有什么作用，或者说反而可能会起到反作用。这种情况下我们还是使用基本算法更好。


## 多代垃圾回收
分代垃圾回收将对象分为新生代和老年代，通过尽量减少从新生代晋升到老年代的对象， 来减少在老年代对象上消耗的垃圾回收的时间。

基于这个理论，大家可能会想到分为 3 代或 4 代岂不更好?这样一来能晋升到最老一代 的对象不就更少了吗?
这种方法就叫作多代垃圾回收(Multi-generational GC)。

![](https://img-vnote-1251075307.cos.ap-beijing.myqcloud.com/1626750460_20210720104619904_218630467.png)

在这个方法中，除了最老的那一代之外，每代都有一个记录集。X 代的记录集只记录来 自比 X 老的其他代的引用。

分代数量越多，对象变成垃圾的机会也就越大，所以这个方法确实能减少活到最老代的对象。

但是我们也不能过度增加分代数量。分代数量越多，每代的空间也就相应地变小了，这 样一来各代之间的引用就变多了，各代中垃圾回收花费的时间也就越来越长了。

综合来看，少设置一些分代能得到更优秀的吞吐量，据说分为 2 代或者 3 代是最好的。


## 列车垃圾回收

列车垃圾回收是为了在分代垃圾回收中利用老年代 GC 而采用的算法，可以控制老年代 GC 中暂停时间的增长。

### 堆的结构

列车垃圾回收中将老年代空间按照一定大小划分，每个划分出来的空间称为车厢，由 1 个以上的车厢连接成的东西就叫作列车。

1 次老年代 GC 是以 1 个车厢作为 GC 对象的。

每个列车和每个车厢都按其产生的顺序被赋予了编号，互相连接。车厢就是以这个顺序 作为 GC 对象的。

我们要为各列车和各车厢准备记录集。列车的记录集里记录的是来自其他列车的引用，车厢的记录集中记录的则是来自同一列车的其他车厢的引用。

![](https://img-vnote-1251075307.cos.ap-beijing.myqcloud.com/1626750461_20210720110214839_177738852.png)

当通过新生代 GC 将对象从新生代空间晋升时，我们要准备已有的车厢或者空的车厢， 将对象安排在分块里。各车厢里的分块是单独作为一个连续的内存空间存在的。也就是说， 我们在这里执行 GC 时，也利用了 GC 复制算法的原理。

在新生代 GC 结束后，就该执行老年代 GC 了。在执行老年代 GC 时，开头列车的开头 车厢是 GC 的对象。在老年代 GC 执行后，因为那些作为 GC 对象的车厢里只剩下了垃圾， 所以我们将这些车厢作为空车厢保留，以便执行下一次新生代 GC。

此外，列车垃圾回收里的对象结构和在 Ungar 的分代垃圾回收里用到的对象结构完全一致。

### 新生代GC
当新生代空间满了的时候，新生代 GC 就开始运行了。新生代 GC 会把根或者老年代对象 引用的新生代对象复制到老年代空间里去。
### 老年代GC
在执行完新生代 GC 之后，我们继续执行老年代 GC。

老年代 GC 是以开头列车的开头车厢作为 GC 对象的。

### 优点
- 能缩减各老年代 GC 所造成的 mutator 的最大暂停时间了。
    - 在列车垃圾回收中，一次老年代 GC 只将堆中非常小的一部分(即车厢) 当成 GC 的对象，因此就能缩减各老年代 GC 所造成的 mutator 的最大暂停时间了。
- 列车垃圾回收还能回收循环的大型垃圾。
    - 列车垃圾回收之所以 能回收跨多个块(在这里也就是车厢)的大型垃圾，是因为列车垃圾回收会把互相引用的对 象安排在同一辆列车上。

### 缺点
在列车垃圾回收中执行写入屏障所产生的额外负担，要比在 Ungar 的分代垃圾回收中执 行时所产生的更大，因此在吞吐量方面，列车垃圾回收要比 Ungar 的分代垃圾回收差一些。

另外，没有考虑到比车厢大的对象。列车垃圾回收是以每个对象都小于一个车厢为前提的。对于比车厢大的对象，需要将其安排到新生代空间和老年代空间以外的堆，使用跟列车垃圾回收不同的方法来执行 GC。