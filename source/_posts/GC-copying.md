---
title: 「垃圾回收的算法与实现-复制算法」.md
date: 2021-07-15 09:20:06
tags: [GC, 垃圾回收, 复制算法]
categories:
- 技术博客
- 原创
---

## 1. 什么是复制算法
GC 复制算法是利用 From 空间进行分配的。当 From 空间被完全占满时，GC 会将活动 对象全部复制到 To 空间。当复制完成后，该算法会把 From 空间和 To 空间互换，GC 也就结 束了。
From 空间和 To 空间大小必须一致。这是为了保证能把 From 空间中的所有活动对象 都收纳到 To 空间里。

<!-- more -->

![](https://img-vnote-1251075307.cos.ap-beijing.myqcloud.com/1626399071_20210715092220674_1058133504.png)

### 1.1. copying()函数
```clang
copying() {
    $free = $to_start
    for(r :$roots) {
        *r = copy(*r)
    }

    swap($from_start, $to_start)
}
```

- $free 是指示分块开头的变量。首先将 $free 设置在 To 空间的开头.
- 复制能从根引用的对象。copy() 函数将作为参数传递的对象 `*r` 复制的同时， 也将其子对象进行递归复制。复制结束后返回指针，这里返回的指针指向的是 `*r` 所在的新 空间的对象。
- 把 From 空间和 To 空间互换，GC 就结束了。

### 1.2. copy()函数
```c
copy(obj) {
    if (obj.tag != COPIED){
        // 将obj复制到$free指向的to区域
        copy_data($free, obj, obj.size)
        // 标记obj为已复制
        obj.tag = COPIED

        // 将obj的forwarding指针指向$free，即新复制后的对象地址
        obj.forwarding = $free

        // $free指针前移
        $free += obj.size

        // 递归复制obj的所有子对象
        for(child: children(obj.forwarding)) {
            *child = copy(*child)
        }
    }

    return obj.forwarding

}
```

![](https://img-vnote-1251075307.cos.ap-beijing.myqcloud.com/1626399072_20210715094052768_462309163.png)

> 从示意图上我们可以看出，obj.tag和obj.forwarding两个指针其实是复用的obj.field1和obj.field2两个域，是它们的别名而已。
> 这也是为啥代码中递归复制子对象时，代码是`for(child: children(obj.forwarding))`遍历的obj.forwarding，因为原先的obj的域已被重写，而obj.forwarding指向的是新复制的对象，新复制的对象的child子对象指向的是原空间的子对象

在此要实现这个方法有 2 个条件。首先每个对象都至少要有 2 个域，分别用作 COPIED 标签和 forwarding 指针。大多数处理系统应该都能满足这个条件。接下来，COPIED 标签为 了挪用 obj 中的域，必须选 1 个 mutator 绝对不会用到的值。这要花些功夫。举个例子，我 们可以空着 mutator，不利用最高有效位，设置最高有效位的值为 COPIED。

### 1.3. new_obj()函数

```c
new_obj(size) {
    if ($free + size > $from_start + HEAP_SIZE / 2) {
        copying()
        if ($free+size > $from_start + HEAP_SIZE / 2) {
            allocation_fail()
        }
    }
    obj = $free
    obj.size = size
    $free += size
    return obj
}
```

在 GC 复制算法中，请注意 GC 完成后只有 1 个分块的内存空间。在每次分配时，只要 把所申请大小的内存空间从这个分块中分割出来给 mutator 就行了。也就是说，这里的分配 跟 GC 标记 - 清除算法中的分配不同，不需要遍历空闲链表。
这里有一点应引起注意，在 GC 复制算法中，HEAP_SIZE 表示的是把 From 空间和 To 空 间加起来的大小。也就是说，From 空间和 To 空间的大小一样，都是 HEAP_SIZE 的一半。
如果分块的大小不够，也就是说分块小于所申请的大小的时候，比起启动 GC，首先应 分配足够大的分块。不然一旦分块大小不够，分配就会失败。
如果分块足够大，那么程序就会把 size 大小的空间从这个分块中分割出来，交给 mutator。不过别忘了还得把 $free 移动 size 个长度。

### 1.4. 执行过程
![](https://img-vnote-1251075307.cos.ap-beijing.myqcloud.com/1626399072_20210715095154891_434267695.png)
![](https://img-vnote-1251075307.cos.ap-beijing.myqcloud.com/1626399072_20210715095214991_1587717359.png)
![](https://img-vnote-1251075307.cos.ap-beijing.myqcloud.com/1626399073_20210715095230821_133855091.png)
![](https://img-vnote-1251075307.cos.ap-beijing.myqcloud.com/1626399073_20210715095248081_1287136028.png)

## 2. 优点
### 2.1. 优秀的吞吐量
GC 复制算法只搜索并复制活动对象，所以跟一般的 GC 标记 - 清除算 法相比，它能在较短时间内完成 GC。也就是说，其吞吐量优秀。
尤其是堆越大，差距越明显。GC 标记 - 清除算法在清除阶段所花费的时间会不断增加， 但 GC 复制算法就不会产生这种消耗。毕竟它消耗的时间是与活动对象的数量成比例的。

### 2.2. 可实现高速分配
GC 复制算法不使用空闲链表。这是因为分块是一个连续的内存空间。因此，调查这个 分块的大小，只要这个分块大小不小于所申请的大小，那么移动 $free 指针就可以进行分配了。
比起 GC 标记 - 清除算法和引用计数法等使用空闲链表的分配，GC 复制算法明显快得多。
### 2.3. 不会发生碎片化
基于算法性质，活动对象被集中安排在 From 空间的开头对吧。像这 样把对象重新集中，放在堆的一端的行为就叫作压缩。在 GC 复制算法中，每次运行 GC 时 都会执行压缩。
因此 GC 复制算法有个非常优秀的特点，就是不会发生碎片化。

### 2.4. 与缓存兼容
在 GC 复制算法中有引用关系的对象会被安排在堆里离彼此较 近的位置。请再看一下图 4.8。BꞋ 引用 AꞋ，GꞋ 引用 EꞋ，图中按照 BꞋ、AꞋ、GꞋ、EꞋ 的顺序排列。
这种情况有一个优点，那就是 mutator 执行速度极快。近来很多 CPU 都通过缓存来高速读取位置较近的对象(1.9.4 节)。这也是借助压缩来完成的，通过压缩来把有引用关系的对 象安排在堆中较近的位置。

## 3. 缺点
### 3.1. 堆使用效率低下
GC 复制算法把堆二等分，通常只能利用其中的一半来安排对象。也就是说，只有一半 堆能被使用。相比其他能使用整个堆的 GC 算法而言，可以说这是 GC 复制算法的一个重大 的缺陷。
### 3.2. 不兼容保守式GC算法
GC 标记 - 清除算法有着跟保守式 GC 算法相兼容的优点。因 为 GC 标记 - 清除算法不用移动对象。
GC 复制算法必须移动对象重写指针，所以有着跟保守式 GC 算法不相容的 性质。
### 3.3. 递归调用函数
复制某个对象时要递归复制它的子对象。因此在每次进行复制的 时候都要调用函数，由此带来的额外负担不容忽视。

## 4. Cheney的复制算法
C. J. Cheney 于 1970 年研究出了 GC 算法 [4]。相比 Fenichel 和 Yochelson 的 GC 复制算法， Cheney 的 GC 复制算法不是递归地，而是迭代地进行复制。

```c
copying() {
    // 初始化scan和free两个指针
    scan = $free = $to_start
    // 复制直接从根引用的对象
    for (r: $roots) {
        *r = copy(*r)
    }

    // 搜索复制完成的对象
    while(scan != $free) {
        for (child: children(scan)) {
            *child = copy(*child)
        }
        scan += scan.size
    }

    // 交换From和TO空间
    swap($from_start, $to_start)
}
```

### 4.1. copy()函数
```c
copy(obj) {
    if (is_pointer_to_heap(obj.forwarding, $to_start) == FALSE) {
        copy_data($free, obj, obj.size)
        obj.forwarding = $free
        $free += obj.size
    }
    return obj.forwarding
}
```

is_pointer_to_heap(obj.forwarding, $to_start)，如果 obj.forwarding 是指 向 To 空间的指针则返回 TRUE，如果不是(即非指针或指向 From 空间的指针)则返回 FALSE。
这里是检查参数 obj 是不是已经复制完毕了。

显而易见，在 Fenichel 和 Yochelson 的 GC 复制算法中也有进行复制对象和设定 forwarding 指针的操作。然而 Cheney 的 GC 复制算法中没有用到 COPIED 标签。在 Fenichel 和 Yochelson 的 GC 复制算法中用 COPIED 标签来区分复制完成或未完成。在 Cheney 的 GC 复制算法中使用 的则是 forwarding 指针。

那么怎么用 forwarding 指针来判断对象是否复制完毕呢?请大家试着想象一下，GC 没 复制的对象，其指针指向哪里呢?当然是指着 From 空间某处的对象喽。反过来就可以这样 判断:哪些对象有着指向 To 空间某处的指针，哪些对象就已经复制完毕了。也就是说，可 知 obj.field1 指向 To 空间的对象 obj 已经复制完毕了。

### 4.2. 执行过程
![](https://img-vnote-1251075307.cos.ap-beijing.myqcloud.com/1626399074_20210715162712063_1292446365.png)
![](https://img-vnote-1251075307.cos.ap-beijing.myqcloud.com/1626399074_20210715162724740_348967150.png)
![](https://img-vnote-1251075307.cos.ap-beijing.myqcloud.com/1626399074_20210715162736620_313050093.png)
![](https://img-vnote-1251075307.cos.ap-beijing.myqcloud.com/1626399075_20210715162751402_97977901.png)


Fenichel 和 Yochelson 的 GC 复制算法采用的是**深度优先搜索**，而 Cheney 的复制算法采用的则是**广度优先搜索**。

### 4.3. 优点
Fenichel 和 Yochelson 的 GC 复制算法是递归算法，而 Cheney 的 GC 复制算法是迭代算 法，因此它可以抑制调用函数的额外负担和栈的消耗。特别是拿堆用作队列，省去了用于搜 索的内存空间这一点，实在是令人赞叹。
### 4.4. 缺点
请大家回忆一下，在 Fenichel 和 Yochelson 的 GC 复制算法中，具有引用关系的对象是相邻的，因此才能充分利用缓存的便利。另一方面，就像我们在图 4.12 中看到的那样，在 Cheney 的 GC 复制算法中，有引用关系的对象，也就是 GꞋ 和 EꞋ，BꞋ 和 AꞋ 并不相邻。
因此我们没法说 Cheney 的 GC 复制算法兼容缓存，只能说它比 GC 标记 - 清除算法和引 用计数法要好一些而已。

## 5. 近似深度优先搜索方法
Cheney 的 GC 复制算法由于在搜索对象上使用了广度优先搜索，因此存在“没法沾缓存的光”的缺点。
### 5.1. Cheney的复制算法（复习）
![](https://img-vnote-1251075307.cos.ap-beijing.myqcloud.com/1626399075_20210716085158239_1742108505.png)
执行 Cheney 的 GC 复制算法时放置各个对象的“页面”如图 4.14 所示，据此我们就知道 了各对象在内存里的配置情况。

![](https://img-vnote-1251075307.cos.ap-beijing.myqcloud.com/1626399075_20210716085220500_825600337.png)

各页面右上角的数字表示的是该页的编号。不过各页面的容量只有 6 个字，也就是说只 能放下 3 个对象。

### 5.2. 前提
接下来要为大家介绍的是对 Cheney 的算法改良后的近似深度优先搜索法。在这个方法中，
我们要用到下面 4 个重要的变量。
• $page
• $local_scan 
• $major_scan 
• $free

首先是 $page，它是将堆分割成一个个页面的数组。$page[i] 指向第 i 个页面的开头。
$local_scan 是将每个页面中搜索用的指针作为元素的数组。$local_scan[i] 指向第 i 个页面中下一个应该搜索的位置。
$major_scan 是指向搜索尚未完成的页面开头的指针。
$free 和在 Cheney 的算法中一样，都是指向分块开头的指针。

### 5.3. 执行过程
首先复制 A 到 To 空间，然后搜索 A，复制 B 和 C。它们都被复制到了第 0 页。到这里 跟 Cheney 的算法完全一样。这时候 To 空间的状态如图 4.15 所示。

![](https://img-vnote-1251075307.cos.ap-beijing.myqcloud.com/1626399076_20210716085352435_973020692.png)
因为 A 已经搜索完了，所以 $local_scan[0] 指向 B。
$free 在此指向第 1 页的开头，也就是说，在下一次复制中对象会被安排到新的页面。 在这种情况下，程序会从 $major_scan 引用的页面的 $local_scan 开始搜索。
此外，当对象被复制到新页面时，程序会根据这个页面的 $local_scan 进行搜索。搜 索会一直持续到新页面被对象全部占满为止。
此时因为 $major_scan 还指向第 0 页，所以还跟之前一样从 $local_scan[0] 开始搜索。 也就是说，下面要搜索 B。

![](https://img-vnote-1251075307.cos.ap-beijing.myqcloud.com/1626399076_20210716085414599_470798539.png)
首先复制了被 B 引用的 D，在这里 D 被安排到了 $page[1] 的开头。像这样对象被安排 到页面开头时，程序会使用该页面的 $local_scan 进行搜索。此时 $local_scan[0] 的搜 索暂停，程序根据 $local_scan[1] 开始搜索对象 D。通过对 D 的搜索，复制了 H 和 I。

![](https://img-vnote-1251075307.cos.ap-beijing.myqcloud.com/1626399076_20210716085430380_1381289425.png)

在这里第 1 页已经满了，$free 指着第 2 页的开头。因此 $local_scan[1] 的搜索暂停， 程序开始通过 $local_scan[0] 进行搜索。也就是说，再次开始对 B 的搜索。

![](https://img-vnote-1251075307.cos.ap-beijing.myqcloud.com/1626399077_20210716085450248_1033141905.png)

对 B 的搜索结束后，E 被复制到了第 2 页。因为程序还要往新页面上复制对象，所以 $local_scan[0] 的搜索再次暂停，开始通过 $local_scan[2] 进行搜索。

因此，下一个要搜索的是 E。通过对 E 的搜索复制 J 和 K。

![](https://img-vnote-1251075307.cos.ap-beijing.myqcloud.com/1626399077_20210716085513630_1610711340.png)

通过对 J 和 K 的搜索，第 2 页被填满了，$free 指向第 3 页的开头。因此我们回到 $major_ scan，再次通过 $local_scan[0] 进行搜索。
接下来的操作和上述步骤一样，这里就不再详细说明了。搜索完对象 C，复制完 A 到 O 的所有对象之后的状态如图 4.20 所示。

![](https://img-vnote-1251075307.cos.ap-beijing.myqcloud.com/1626399078_20210716085528113_46637298.png)

这样终于搜索完第 0 页了，$major_scan 指向 $page[1]。虽然还有没搜索过的对象， 但这些对象都没有子对象，所以程序不对它们进行复制。


### 5.4. 执行结果
那么，此 GC 复制算法是如何通过近似深度优先搜索来安排对象的呢?结果如图 4.21 所
示。请大家将图 4.21 与图 4.14(Cheney 的 GC 复制算法的执行结果)相比较看看。

![](https://img-vnote-1251075307.cos.ap-beijing.myqcloud.com/1626399078_20210716085559718_1536331.png)

很明显能够看出，跟 Cheney 的使用广度优先搜索的 GC 复制算法不同，在使用近似深 度优先搜索的情况下，不管在哪一个页面里，对象间都存在着引用关系。
为什么会出现这样的结果呢?这是因为此算法采用的不是完整的广度优先搜索，而是在 每个页面上分别进行广度优先搜索。这里利用了我们在 4.5.1 节中提到的广度优先搜索的性质， 即在搜索一开始把有引用关系的对象安排在同一个页面中。



## 6. 多空间复制算法
GC 复制算法最大的缺点是只能利用半个堆。这是因为该算法将整个堆分成了两半，每 次都要腾出一半。
那么把堆再作细分会如何呢?举个例子，我们不把堆分成 2 份，而是分成 10 份，其中 需要拿出 2 块空间分别作为 From 空间和 To 空间来执行 GC 复制算法。反正无论如何都要空 出 1 块空间来当 To 空间，那我们就把这个额外负担降到整体的 1/10 就行了。

接下来，我们必须用别的方法对剩下的 8 块空间执行 GC。在这里 GC 标记-清除算法又登场了。

多空间复制算法说白了就是把堆 N 等分，对其中 2 块空间执行 GC 复制算法，对剩下的 (N-2)块空间执行 GC 标记 - 清除算法，也就是把这 2 种算法组合起来使用。

### 6.1. cmulti_space_copying()函数
```c
cmulti_space_copying() {
    $free = $heap[$to_space_index]
    // 给活动对象打上标记
    for (r : $roots) {
        *r = mark_or_copy(*r)
    }
    // 清除阶段
    for (index: 0..(N-1)) {
        if (is_copying_index(index) == FALSE) {
            sweep_block(index)
        }
    }

    $to_space_index = $from_space_index
    $from_space_index = ($from_space_index + 1) % N
}
```

这里将堆 N 等分，开头分别是 $heap[0], $heap[1], ..., $heap[N-1]。这时 $heap[$to_ space_index] 表示的是 To 空间。每次执行 GC 时，To 空间都会像 $heap[0], $heap[1], ..., $heap[N-1], $heap[0] 这 样 进 行 替 换。From 空 间 在 To 空 间 的 右 边，也 就 是 $heap[1], $heap[2], ..., $heap[N-2], $heap[N-1]。

在第 4 行和第 5 行给活动对象打上标记。这个操作一眼看去很像 GC 标记 - 清除算法中 的标记阶段。
不过有一点不同，就是该算法考虑到了对象在 From 空间($heap[$from_space_ index])里的情况。当参数 obj 在 From 空间里时，mark_or_copy() 函数会将其复制到 To 空间，返回其复制完毕的对象。如果 obj 在除 From 空间以外的其他地方，mark_or_copy() 函数会像通常的标记函数一样给对象打上标记，递归标记或者复制它的子对象。关于 mark_ or_copy() 函数，我们将在下一节中进行介绍。

第 8 行到第 12 行是清除阶段。这里跟以往的 GC 标记 - 清除算法基本一致，位于 From 空间和 To 空间以外的分块且没被标记的对象会被连接到空闲链表。

最后将 To 空间和 From 空间往右移动一个位置，GC 就结束了。

### 6.2. 执行过程
在这里我们用图来更具体地看一下多空间复制算法的流程吧。我们设份数 N 为 4，请看图 4.22

![](https://img-vnote-1251075307.cos.ap-beijing.myqcloud.com/1626399079_20210716092634396_51311353.png)
> 注意：该图未考虑碎片化

To 空间 $heap[0] 空着，其他的 3 个空间都安排有对象。在这个状态下执行 GC 就会变 成图 4.23 这样。
![](https://img-vnote-1251075307.cos.ap-beijing.myqcloud.com/1626399079_20210716092705393_1248967424.png)

我们将 $heap[0] 作为 To 空间，将 $heap[1] 作为 From 空间执行了 GC 复制算法。此 外，在 $heap[2] 和 $heap[3] 中执行了 GC 标记 - 清除算法，将分块连接到了空闲链表。 当 mutator 申请分块时，程序会从这个空闲链表或 $heap[0] 中分割出分块给 mutator。

接下来，将 To 空间和 From 空间分别移动一个位置，将 $heap[1] 作为 To 空间，将 $heap[2] 作为 From 空间，执行下面的 GC。

mutator 基于这个状态重新开始执行。让我们来设想一下再次没有了分块的情况，请看图 4.24。

![](https://img-vnote-1251075307.cos.ap-beijing.myqcloud.com/1626399080_20210716092801509_1890329390.png)

请大家注意，这次 $heap[1] 是 To 空间，$heap[2] 是 From 空间。在这种状态下执行 GC，堆就会变成如图 4.25 所示的状态。

![](https://img-vnote-1251075307.cos.ap-beijing.myqcloud.com/1626399080_20210716092850955_892984012.png)

$heap[2] 的活动对象都被复制到了 $heap[1] 中，在 $heap[0] 和 $heap[3] 中执行了 GC 标记 - 清除算法。
此外，为了准备下一次 GC，我们将 $heap[2] 设为 To 空间，将 $heap[3] 设为 From 空间。

### 6.3. 优点
多空间复制算法没有将堆二等分，而是分割成了更多块空间，从而更有效地利用了堆。 以往的 GC 复制算法只能使用半个堆，而多空间复制算法仅仅需要空出一个分块，不能使用 的只有 1/N 个堆。
### 6.4. 缺点
执行 GC 复制算法的只有 N 等分中的两块空间，对于剩下的(N-2)块空间执行的是 GC 标记 - 清除算法。因此就出现了 GC 标记 - 清除算法固有的问题 — 分配耗费时间、分块碎片化等。
只要把执行 GC 标记 - 清除算法的空间缩小，就可以缓解这些问题。打个比方，如果让N = 3，就能把发生碎片化的空间控制在整体堆的 1/3。不过这时候为了在剩下的 2/3 的空间 里执行 GC 复制算法，我们就不能使用其中的一半，也就是堆空间的 1/3。
综上，不管是 GC 标记 - 清除算法还是 GC 复制算法，都各有各的缺点。大家也都明白， 几乎不存在没有缺点的万能算法。


## 7. 总结
- 复制算法将内存堆空间一分为二，将要复制活动对象的原空间From空间和将要粘贴活动对象的新空间To空间
- From空间和To空间大小完全一致，为了保证能够将From中的所有活动对象都能复制到To空间
- 当From空间被完全占满时，GC会将其内的所有活动对象全部复制到To空间，当复制完成后，From和To互换
- 复制过程中采用递归式的深度优先算法，结果是相互引用的对象在堆内被安排在比较近的位置
- 复制算法的优点有：优秀的吞吐量，可实现高速分配， 不会发生碎片化， 与缓存兼容
- 复制算法的缺点有：堆使用率低下， 不兼容保守式GC算法， 递归调用函数
- 针对缺点递归调用函数，Cheney提出了Cheney复制算法，复制过程不是递归地，而是迭代进行复制。优点是它可以抑制调用函数的额外负担和栈的消耗，但缺点是导致相互引用的对象在复制后，可能并不相邻，导致无法兼容缓存。
- 针对Cheney算法使用广度优先导致有引用关系对象并不相邻，无法兼容缓存的问题，还有一种近似深度优先搜索方法。
- 针对堆效率使用低下，只能使用一半堆这个缺点，可以采用多空间复制算法来优化。将堆N等分，其中两份分别作为From和To使用复制算法，其余N-2份使用标记-清除算法。优点是提高了堆的使用效率，缺点是由于采用了标记-清除算法，也会有标记-清除算法固有的问题--时间消耗，分块碎片化等问题。