---
title: 「垃圾回收的算法与实现-标记压缩算法」.md
date: 2021-07-17 22:08:17
tags: [GC, 垃圾回收, 标记压缩算法]
categories:
- 技术博客
- 原创
---

## 什么是标记-压缩算法
标记-压缩算法是标记-清除算法与复制算法结合的产物。

标记-压缩算法由 `标记阶段` 和 `压缩阶段` 构成。

### Lisp2算法
Lisp2 算法在对象头里为 forwarding 指针留出了空间。这里的 forwarding 指针跟 GC 复制算法中的用法一样。不过在 GC 复制算法中，我们将复制后的对象名(如 AꞋ、BꞋ 等)用GC标记-压缩算法forwarding指针表示，在本章中则将对象的目标地点用箭头指出。这是因为设定 forwarding 指针时还不存在移动完毕的对象。

![](https://img-vnote-1251075307.cos.ap-beijing.myqcloud.com/1626533583_20210717221243262_1695826683.png)

### 概要
![](https://img-vnote-1251075307.cos.ap-beijing.myqcloud.com/1626533584_20210717221304179_356098197.png)
![](https://img-vnote-1251075307.cos.ap-beijing.myqcloud.com/1626533585_20210717221319763_2052956437.png)
![](https://img-vnote-1251075307.cos.ap-beijing.myqcloud.com/1626533585_20210717221331760_419080310.png)


> 在 Lisp2 算法中，压缩阶段并不会改变对象的排列顺序，只是缩小了它们之间的空隙， 把它们聚集到了堆的一端。

```c
compaction_phase(){
    // 设定 forwarding 指针
    set_forwarding_ptr()
    // 更新指针
    adjust_ptr()
    // 移动指针
    move_obj()
}
```


### 步骤1-设定forwarding指针

```c
set_forwarding_ptr() {
    scan = new_address = $heap_start
    while(scan < $heap_end) {
        if (scan.mark == TRUE) {
            scan.forwarding = new_address
            new_address += scan.size
        }
        scan += scan.size
    }
}
```

scan 是用来搜索堆中的对象的指针，new_address 是指向目标地点的指针。
一旦 scan 指针找到活动对象，就会将对象的 forwarding 指针的引用目标从 NULL 更新到 new_address，将 new_address 按对象长度移动。

![](https://img-vnote-1251075307.cos.ap-beijing.myqcloud.com/1626533586_20210717221930241_1883891657.png)

我们在这里给 forwarding 指针留出空间是有原因的。GC 复制算法把 From 空间和 To 空 间完全分割开来了，因此将对象 A 作为 AꞋ 移动到 To 空间后，对象 A 的域就留在了 From 空 间里，这样一来就能把 forwarding 指针记录在这个域里。
然而，因为在 GC 标记 - 压缩算法中新空间和原空间是同一个空间，所以有可能出现把移动前的对象覆盖掉的情况。因此在移动对象前，需要事先将各对象的指针全部更新到预计要移动到的地址。这样一来，之后只要移动对象，GC 就结束了。
为了在移动对象前更新指针，不能在域中设定 forwarding 指针。因为这样一来 mutator 所使用的数据会消失掉。因此这个算法需要确保专门的域。

### 步骤2-更新指针

```c
adjust_ptr() {
    // 重写根的指针
    for(r : $roots) {
        *r = (*r).forwarding
    }

    scan = $heap_start
    // 重写所有对象的指针
    while(scan < $heap_end) {
        if (scan.mark == TRUE) {
            for (child: children(scan)) {
                *child = (*child).forwarding
            }
        }
        scan += scan.size
    }
}
```

> 这是第 2 次对整个堆执行搜索了。

![](https://img-vnote-1251075307.cos.ap-beijing.myqcloud.com/1626533587_20210717222425941_68187831.png)

### 步骤3-移动对象
在步骤 3 中搜索整个堆，将活动对象移动到 forwarding 指针的引用目标处。请大家注意，
这样一来就是第 3 次搜索整个堆了。

```c
move_obj() {
    scan = $free = $heap_start
    while(scan < $heap_end) {
        // 找到活动对象，移动到forwarding指针的引用目标处
        if (scan.mark == TRUE) {
            new_address = scan.forwarding
            copy_data(new_address, scan, scan.size)
            new_address.forwarding = NULL
            // 将其 forwarding 指针设为 NULL，取消标志位，再将 $free 指针移动 new_address.size 个长度。
            new_address.mark = FALSE
            $free += new_address.size
            scan += scan.size
        }
    }
}
```

> 在这里大家可能会担心通过 copy_data() 函数会把活动对象覆盖了呢，事实上没有必要担心。如 5.1.2 节中所述，本算法不会改变对象的排列顺序，只是把对象按顺序从堆各处向左移动到堆的开头。因此，这就保证了目标堆中已经没有活动对象了。

![](https://img-vnote-1251075307.cos.ap-beijing.myqcloud.com/1626533587_20210717223549840_1424091766.png)

## 优点
### 可有效利用堆
相比复制算法只能利用1/2堆的情况，标记-压缩算法可以在整个堆中安排对象，堆使用率几乎是复制算法的2倍。因为要留出用于 forwarding 指针的空间，所以严格来说不到 2 倍。

另一方面，尽管 GC 标记-清除算法也能利用整个堆，但因为没有压缩的过程，所以会产生碎片化，不能充分有效地利用堆。

## 缺点
### 压缩花费计算成本
Lisp2 算法的压缩中，必须对整个堆进行 3 次搜索。执行该算法所花费的时间是和堆大小成正比的。GC 标记 - 压缩算法的吞吐量要劣于其他算法。

在 GC 标记-清除算法中，清除阶段也要搜索整个堆，不过搜索 1 次就够了。但 GC 标记-压缩算法要搜索 3 次，这样就要花费约 3 倍的时间，这是一个相当巨大的缺陷，特别是堆越大，所消耗的成本也就越大。

## Two-Finger 算法

### 前提
Two-Finger 算法有着很大的制约条件，那就是“必须将所有对象整理成大小一致”。之前介绍的算法都没有这种限制，而 Two-Finger 算法就必须严格遵守这个制约条件。

Two -Finger 算法和 Lisp2 算法不同，没有必要为 forwarding 指针准备空间，只需要在原空间对象的域中设定 forwarding 指针即可。

### 概要

Two-Finger 算法由以下 2 个步骤构成。

1. 移动对象 
2. 更新指针

![](https://img-vnote-1251075307.cos.ap-beijing.myqcloud.com/1626533588_20210717224115440_1005065347.png)

在 Lisp2 算法中，通过执行压缩操作使活动对象往左边滑动。而在 Two-Finger 算法中， 则是通过执行压缩操作来让活动对象填补空闲空间。此时为了让对象能恰好填补空闲空间， 必须让所有对象大小一致。

因为在 Two-Finger 算 法中，我们要利用放置非活动对象的空间来作为活动对象的目标空间，这是为了让移动前的 对象不会在 GC 过程中被覆盖掉。这样一来，我们就能把 forwarding 指针设定在这个移动前 的对象的域中，没有必要多准备出 1 个字了。

### 步骤1-移动对象
首先用 `$free` 和 live 这 2 个指针，从两端向正中间搜索堆。
`$free` 是用于寻找非活动对象(目标空间)的指针，live 是用于寻找活动对象(原空间) 的指针。

![](https://img-vnote-1251075307.cos.ap-beijing.myqcloud.com/1626533589_20210717224308072_26919727.png)

2 个指针在发现目标空间和原空间的对象时会移动对象。

![](https://img-vnote-1251075307.cos.ap-beijing.myqcloud.com/1626533590_20210717224327957_1468285819.png)

```c
move_obj() {
    $free = $heap_start
    live = $heap_end - OBJ_SIZE
    while (TRUE) {
        // $free 指针跳过活动对象进行搜索
        while ($free.mark == TRUE) {
            $free += OBJ_SIZE
        }
        // live 指针跳过非活动对象进行搜索
        while(live.mark == FALSE) {
            live -= OBJ_SIZE
        }
        // live 指针指向活动对象，$free 指针指向非活动对象。此时 2 个指针如果尚未交错，就会进行移动对象的操作。
        if ($free < live) {
            copy_data($free, live, OBJ_SIZE)
            live.forwarding = $free
            live.mark = FALSE
        } else {
        // 如果 2 个指针交错，则意味着对整个堆的搜索结束，此步骤告终。
            break
        }
    }
}
```

因为对象的大小是一致的，所以这里就将其设为 OBJ_SIZE。`$free` 指针从左端的对象 (`$heap_start`)开始向右搜索堆;另一方面，live 指针从右端的对象(`$heap_end-OBJ_SIZE`)开始向左搜索堆。

### 步骤2-更新指针
接下来寻找指向移动前的对象的指针，把它更新，使其指向移动后的对象。

![](https://img-vnote-1251075307.cos.ap-beijing.myqcloud.com/1626533591_20210717224831019_745172256.png)

当对象移动结束时，`$free` 指针指向分块的开头，这时位于 `$free` 指针右边的是以下两 者之一。

- 非活动对象
- 移动前的对象

因此，指向 `$free` 指针右边地址的指针引用的是移动前的对象。

```c
adjust_prt() {
    for (r : $roots) {
        if (*r >= $free) {
            *r = (*r).forwarding
        }
    }
    scan = $heap_start
    while(scan < $free) {
        scan.mark = FALSE
        for (child : children(scan)) {
            if (*child >= $free) {
                *child = (*child).forwarding
            }
        }
        scan += OBJ_SIZE
    }
}
```

按照先根后堆的顺序来调查指针。当指针引用的对象在 `$free` 右边时，就意味着这个对象已经被移动到了某处。大家也知道，在这种情况下必须将指针的引用目标更新到移动后的对象。
因为活动对象已经被安排在 `$heap_start` 和 `$free` 之间，所以搜索完 `$free` 时压缩就 结束了。
另外，因为此时 `$free` 指针指向分块的开头，所以可以就这样直接进行分配操作。

### 优点
Lisp2 算法要事先确保每个对象都留有 1 个字用于 forwarding 指针，这就压迫了堆。然而 因为 Two-Finger 算法能把 forwarding 指针设置在移动前的对象的域里，所以不需要额外的内存空间以用于 forwarding 指针，因此在内存的使用效率上，该算法要比 Lisp2 算法的使用效率高。
此外，在 Two-Finger 算法中，压缩所带来的搜索次数只有 2 次，比 Lisp2 算法少 1 次， 在吞吐量方面占优势。
### 缺点
就像我们在介绍 GC 复制算法时所说的那样，将具有引用关系的对象安排在堆中较近的位置，就能够通过缓存来提高访问速度。不过 Two-Finger 算法则不考虑对象间的引用关系， 一律对其进行压缩，结果就导致对象的顺序在压缩前后产生了巨大的变化。因此，我们基本上也无法期待这个算法能沾缓存的光。
此外该算法还有一个限制条件，那就是所有对象的大小必须一致。因为能消除这个限制的处理系统不太多，所以这点制约了 Two-Finger 算法的应用范围。不过，我们用第 2 章中介绍到的 BiBOP 法就能克服这个问题。只要把同一大小的对象安排在同一个分块里，就能对每个分块应用 Two-Finger 算法了。


## 表格算法
表格算法和Two-Finger 算法一样，都是执行 2 次压缩操作。

### 概要
表格算法通过以下 2 个步骤来执行压缩。

1. 移动对象(群)以及构筑间隙表格(break table) 
2. 更新指针

当然，我们不能光让对象群移动，还需要预留`更新指针所用的信息`。其他的压缩算法都用 forwarding 指针来作为更新指针所用的信息，不过在表格算法中则使用间隙表格。

所谓间隙表格，大概意思就是“按照一个个活动对象群记录下压缩所需信息的表格”。

在这个表格里事先放入移动前的对象群的信息(位于对象群的首地址和较低地址的分块 的总大小)。间隙表格就是图 5.12 这样的表格。不过为了方便计算地址，我们将 1 个字的大小定为 50。

![](https://img-vnote-1251075307.cos.ap-beijing.myqcloud.com/1626541270_20210717233829276_2132960935.png)

随着对象的移动，间隙表格会被放在空闲空间里。不过，间隙表格的各入口至少需要 2 个字。也就是说，这个算法有个制约条件，就是每个对象都必须在 2 个字以上。

### 步骤1（前半部分）- 移动对象群

![](https://img-vnote-1251075307.cos.ap-beijing.myqcloud.com/1626541271_20210717235718896_729915174.png)

```c
move_obj() {
    scan = $free = $heap_start
    size = 0
    // scan 指针负责寻找活动对象群的开头。也就是说，直到它找到活 动对象为止，都会跳过非活动对象。
    // 与此同时，使用 size 计算 scan 指针跳过的空间的大小。
    while(scan < $heap_end) {
        size += scan.size
        scan += scan.size
    }
    // 搜索结束时 scan 指针指向活动对象群的开头。
    // 将这个位置记录在 live 指针 里。这个指针由 scan 指针发现，用于记录活动对象群的开头。
    live = scan
    // 继续使用 scan 指针搜索连续的活动对象群。
    while(scan.mark == TRUE) {
        scan += scan.size
    }
    // live 和 scan 之间已经连续存在活动对象群了。
    slide_objs_and_mark_bt(scan, $free, live, size)
    // 准备下一次移动，将$free移动(scan-live)个大小，即$free的移动大小等于要移动的对象群的大小。
    $free += (scan - live)
}
```

在这里 scan 指针用于寻找活动对象群，从堆开头开始搜索。`$free` 是指向对象群目标 空间的指针。size 是保持分块大小的变量，这里的分块指的是用来记录到间隙表格里的分块。

slide_objs_and_make_bt() 函数中执行移动活动对象群和构筑间隙表格的操作。对象群的原空间是 live，目标空间是 `$free`，要移动的对象群的总大小是(scan- live)。

slide_objs_and_mark_bt()执行结束时堆的状态：

![](https://img-vnote-1251075307.cos.ap-beijing.myqcloud.com/1626541273_20210718000148423_1257737754.png)
![](https://img-vnote-1251075307.cos.ap-beijing.myqcloud.com/1626541275_20210718000331278_1116894057.png)

这里和 Lisp2 算法一样，都是通过把活动对象向左滑动来执行压缩。不过这里不是分别移动各个对象，而是移动连续的活动对象群。在此分别移动的是对象群 BC 和 FG。

### 步骤1（后半部分）- 构筑间隙表格
每次移动对象群时，都需要把移动前的信息注册到 间隙表格里。注册入口是所移动的对象群的首地址(live)和此前对象群滑动大小(size)的 组合。

间隙表格的构筑是在代码清单中slide_objs_and_make_bt() 函数的内部执行的。因为构筑间隙表格是一项很复杂的处理，所以我们在这里就不采用伪代码，而是采用图来为大家解说。

间隙表格的构筑由以下两项操作构成。

- 移动对象群
- 移动间隙表格

![](https://img-vnote-1251075307.cos.ap-beijing.myqcloud.com/1626541278_20210718000528874_483857572.png)

如图 5.17(a)，在移动对象群 BC 的同时构筑间隙表格。将 BC 的首地址(100)以及 BC 左边分块的总大小(100)组合成一对，通过 scan 指针写入已知为分块的 350 号地址。

接下来请看图 5.17(b)，这里进行的是移动对象群 FG 的操作。这时要注册到间隙表格的 信息是(550，300)，不过不能直接将该信息写入(100，100)之后(即 450 号地址)。因为对象群 FG 要移到这里。

这时我们要让所有已有的间隙表格“先行回避”，也就是把(100，100)移动到 FG 右边的分块(800 号地址)。这样一来 FG 就能移动了，我们将其移动。

最后，将这次要注册的信息(550，300)设置在移动 FG 后空出来的空间，也就是 800 号 地址左边的 700 号地址里。

这确实是很复杂的操作，完成后的状态如图 5.17(c) 所示。在这里请注意间隙表格的入口顺序。各个入口不是按入口里的第一元素排列的，也就是说，不是按活动对象群的首地址(live)的顺序排列的。这是为什么呢?

在图 5.17(b) 中，因为间隙表格妨碍到对象群 FG 的移动，所以我们让它先回避到 800 号地址，这之后再移动 FG，将(550，300)新注册到已成为分块的 700 号地址。 像这样往已有的间隙表格里新追加入口时，有时会出现只在表格左侧有空闲空间的情况。

在这种情况下，表格的入口顺序就乱了。

当然，注册入口时也可以每次都按 live 的顺序排列，不过这样就产生了额外的消耗。 然而，因为各入口没有按第一元素 live 的顺序排列，所以增大了下一个步骤“更新指针”的计算量。

### 步骤2-更新指针
在 adjust_ptr() 函数中，**将引用`移动前的对象的指针`全部换成引用`移动后的对象的指针`**。

```c
adjust_ptr() {
    for(r:$roots) {
        *r = new_address(*r)
    }
    scan = $heap_start
    while(scan < $free) {
        scan.mark = FALSE
        for (child: children(scan)) {
            *child = new_address(*child)
        }
        scan += scan.size
    }
}
// 这个函数会返回参数 obj 移动后的地址
new_address(obj) {
    best_entry = new_bt_entry(0,0)
    // 调查间隙表格，在持有 obj 及其以下的地址(address)的入口中， 寻找地址最大的入口。
    // 这样一来就得到了持有 obj 所属对象群信息的入口。这个入口就是 best_entry。
    for(entry: break_table) {
        if (entry.address <= obj && $best_entry.address < entry.address) {
            best_entry = entry
        }
    }
    // 那么 best_entry 又意味着什么呢?它是一个入口，这个入口持有 obj 所属对象群移动前的信息。
    // 属于这个对象群的所有对象都会被向左移动 best_entry.size 个大小。
    // 因此， obj 移动后的地址就变成了 obj-best_entry.size
    return obj - best_entry.size
}
```

举个例子：
![](https://img-vnote-1251075307.cos.ap-beijing.myqcloud.com/1626541280_20210718001327076_1821125062.png)

打个比方，在图 5.18 中，如果我们想知道 B 移动到了 BꞋ，首先就要以 B 的地址 100 为线索调查间隙表格，然后就会发现入口(100，100)是 best_entry，接下来可由 B 的地址 100 求得 best_entry.size，即将 B 的地址减去 100 得到 BꞋ 的地址 0。
同理，我们可以从 F 的地址 550 减去入口(550，300)中的 300，得到 FꞋ 的地址 250。

### 优点
在表格算法中，没有必要为压缩准备出多余的空间，这是因为该算法很好地利用了分块， 保留了更换指针所必需的信息。
虽然在不需要多余空间这一点上表格算法跟 Two-Finger 一样，不过在压缩前后保留对象顺序这一点上，表格算法可以说比 Two-Finger 要优秀得多。这是因为在表格算法中，可以通过缓存来提高对象的访问速度。
### 缺点
**要维持间隙表格需要付出很高的代价**。考虑到每次移动活动对象群都要进行表格的移动和更新，代价高也是理所当然的。
此外，在更新指针时也不能忽略搜索表格所带来的消耗。在更新指针前，如果先将表格排序，则表格的搜索就能高速化。不过排序表格也需要相应的消耗，所以并不能从根本上解决问题。

### 小结
1. 表格算法通过两个步骤来执行压缩：1️⃣：移动对象（群）以及构筑间隙表格。 2️⃣：更新指针。
2. 间隙表格是一个存放`对象群移动前的位置`以及`要移动的分块大小`的表格。
3. 间隙表格不需要额外的空间存储，而是存放在空闲空间里。因此在移动对象群以及构筑间隙表格时，间隙表格的存储位置也会发生移动。
4. 对象移动后，要依赖间隙表格，更新引用移动前对象的指针为移动后对象的指针。
5. 相比于Lisp2算法搜索堆3次，表格算法只需要搜索2次，效率更快。
6. 相比于Two-Finger算法，压缩前后，对象的顺序保持一致，可以通过缓存来提高对象的访问速度。
7. 缺点是，要维持间隙表格需要付出很高的代价。

## 总结
1. 本节总共介绍了三种标记-压缩算法：Lisp2算法，Two-Finger算法， 表格算法。
2. Lisp2算法分三个步骤：1-设定forwarding指针。2-更新指针。3-移动对象
3. Lisp2算法需要一个额外的forwarding域来记录压缩后的指针
4. Lisp2算法的优点是可有效的利用堆，不会产生碎片化。而且压缩后对象的顺序不会发生变化。缺点是由于压缩需要对堆进行3次搜索，因此压缩的时间成本会高于其他算法。
5. Two-Finger算法分两个步骤：1.移动对象。2.更新指针。
6. Two-Finger算法不需要额外的域记录forwarding，而是把forwarding指针设置在移动前的对象的域里
7. Two-Finger算法需要两个指针`$free`和`live`一前一后向中间分别搜索非活动对象和活动对象
8. Two-Finger算法的优点向较于Lisp2算法不需要额外的域保存forwarding指针，堆的利用率高。而且只需要搜索堆2次，吞吐量也是高于Lisp2算法。
9. 缺点是Two-Finger算法压缩后，对象的顺序发生巨大变化。第二个是该算法限制所有对象大小都一致，这限制了其应用范围。
10. 表格算法分两个步骤：1:移动对象并构筑间隙表格。2:更新指针。
11. 间隙表格是一个存放`对象群移动前的位置`以及`要移动的分块大小`的表格。
12. 间隙表格不需要额外的空间存储，而是存放在空闲空间里。因此在移动对象群以及构筑间隙表格时，间隙表格的存储位置也会发生移动。
13. 对象移动后，要依赖间隙表格，更新引用移动前对象的指针为移动后对象的指针。
14. 相比于Lisp2算法搜索堆3次，表格算法只需要搜索2次，效率更快。
15. 相比于Two-Finger算法，压缩前后，对象的顺序保持一致，可以通过缓存来提高对象的访问速度。
16. 缺点是，要维持间隙表格需要付出很高的代价。
