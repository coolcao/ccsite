---
title: 「垃圾回收的算法与实现-标记清除法」.md
date: 2021-05-28 11:46:18
tags: [GC,垃圾回收,标记清除]
categories:
- 技术博客
- 读书笔记
---

# 垃圾回收的算法与实现笔记-标记清除法

## 什么是标记清除法
标记清除法是由**标记阶段**和**清除阶段**构成。
标记阶段是把所有活动对象都做上标记的阶段。清除阶段是把那些没有标记的对象，也就是非活动对象回收的阶段。通过这两个阶段，就可以令不能利用的空间重新得以利用。

<!--more-->

标记清除算法的伪代码：
```
mark_sweep(){
 mark_phase()
 sweep_phase()
}
```

![](https://img-vnote-1251075307.cos.ap-beijing.myqcloud.com/1626191397_20210528115107666_89528890.png)

### 标记阶段
```
mark_phase(){
 for(r : $roots) 
   mark(*r)
}
mark(obj) {
if (obj.mark == FALSE) {
  obj.mark = TRUE
    for (child: children(obj)) {
      mark(*child)
    }
  }
}
```
> 从根开始，递归标记被引用的对象。

标记完所有活动对象后，标记阶段就结束了。标记阶段结束时的堆如图：
![](https://img-vnote-1251075307.cos.ap-beijing.myqcloud.com/1626191398_20210528135433508_1473501330.png)

用一句话概括，标记阶段就是“遍历对象并标记”的处理 过程。

### 清除阶段
在清除阶段中，collector 会遍历整个堆，回收没有打上标记的对象(即垃圾)，使其能再 次得到利用。

```
sweep_phase(){
    sweeping = $heap_start 
    while(sweeping < $heap_end)
        if(sweeping.mark == TRUE) 
            sweeping.mark = FALSE
        else
            sweeping.next = $free_list 
            $free_list = sweeping
        sweeping += sweeping.size 
}
```

在清除阶段，我们使用变量 sweeping 遍历堆，具体来说就是从堆首地址 $heap_start 开始，按顺序一个个遍历对象的标志位。
设置了标志位，就说明这个对象是活动对象。活动对象必然是不能回收的。在第 5 行我 们取消标志位，准备下一次的 GC。
我们必须把非活动对象回收再利用。回收对象就是把对象作为分块，连接到被称为“空 闲链表”的单向链表。在之后进行分配时只要遍历这个空闲链表，就可以找到分块了。

![](https://img-vnote-1251075307.cos.ap-beijing.myqcloud.com/1626191398_20210528140226729_355436106.png)

### 分配
我们在清除阶段已经把垃圾对象连接到空闲链表了。搜索空闲链表并寻找 大小合适的分块，这项操作就叫作分配。执行分配的函数 new_obj()。

```
new_obj(size) {
  chunk = pickup_chunk(size, $free_list)
  if (chunk != null) {
    return chunk
  }
  else {
    allocation_fail()
  }
}
```

第 2 行的 pickup_chunk() 函数用于遍历 $free_list，寻找大于等于 size 的分块。它 不光会返回和 size 大小相同的分块，还会返回比 size 大的分块。如果它找到和 size 大小 相同的分块，则会直接返回该分块;如果它找到比 size 大的分块，则会将其分割成 size 大 小的分块和去掉 size 后剩余大小的分块，并把剩余的分块返回空闲链表。
如果此函数没有找到合适的分块，则会返回 NULL。返回 NULL 时分配是不会进行的。

> First -fit、Best -fit、Worst -fit 的不同
> 之前我们讲的分配策略叫作 First -fit。因为在 pickup_chunk() 函数中，最初发现大于等于 size 的分块时就会立即返回该分块。
> 然而，分配策略不止这些。还有遍历空闲链表，返回大于等于 size 的最小分块，这种策略叫 作 Best -fit。
> 还有一种策略叫作 Worst -fit，即找出空闲链表中最大的分块，将其分割成 mutator 申请的 大小和分割后剩余的大小，目的是将分割后剩余的分块最大化。但因为 Worst -fit 很容易生成大 量小的分块，所以不推荐大家使用此方法。
> 除去 Worst -fit，剩下的还有 Best -fit 和 First -fit 这两种。当我们使用单纯的空闲链表时， 考虑到分配所需的时间，选择使用 First -fit 更为明智。

### 合并
根据分配策略的不同可能会产生大量的小分块。但如果它们是连续的， 我们就能把所有的小分块连在一起形成一个大分块。这种“连接连续分块”的操作就叫作合 并(coalescing)，合并是在清除阶段进行的。

```
sweep_phase() {
  sweeping = $heap_start
  while(sweeping < $heap_end) {
    if (sweeping.mark == TRUE) {
      sweeping.mark = FALSE
    } else {
      if (sweeping == $free_list + $free_list.size) {
        $free_list.size += sweeping.size
      } else {
        sweeping.next = $free_list
        $free_list = sweeping
      }
      sweeping += sweeping.size
    }
  }
}
```


## 优点
- **实现简单**
    标记清除算法的优点，与其他算法相比，就是实现简单。
- **与保守式GC算法兼容**
    标记 - 清除算法因为不会移动对象，所以非常适合搭配保守式 GC 算法。
## 缺点
### 碎片化
> 主要是因为分配时产生的碎片化
![](https://img-vnote-1251075307.cos.ap-beijing.myqcloud.com/1626191398_20210528141438057_1662611235.png)
在 GC 标记 - 清除算法的使用过程中会逐渐产生被细化的分块，不久后就会导致无数的 小分块散布在堆的各处。我们称这种状况为碎片化(fragmentation)。
如果发生碎片化，那么即使堆中分块的总大小够用，也会因为一个个的分块都太小而不 能执行分配。
此外，如果发生碎片化，就会增加 mutator 的执行负担。
因为分块在堆中的分布情况取决于 mutator 的运行情况，所以只要使用 GC 标记 - 清除 算法，就会或多或少地产生碎片化。
### 分配速度
GC 标记 - 清除算法中分块不是连续的，因此每次分配都必须遍历空闲链表，找到足够 大的分块。最糟的情况就是每次进行分配都得把空闲链表遍历到最后。
### 与写时复制不兼容
写时复制技术(copy-on-write)是在 Linux 等众多 UNIX 操作系统的虚拟存储中用到的高速 化方法。
打个比方，在 Linux 中复制进程，也就是使用 fork() 函数时，大部分内存空间都不会被复制。只是复制进程，就复制了所有内存空间的话也太说不过去了吧。因此，写时复 制技术只是装作已经复制了内存空间，实际上是将内存空间共享了。
在各个进程中访问数据时，能够访问共享内存就没什么问题了。
然而，当我们对共享内存空间进行写入时，不能直接重写共享内存。因为从其他程序访 问时，会发生数据不一致的情况。在重写时，要复制自己私有空间的数据，对这个私有空间 进行重写。复制后只访问这个私有空间，不访问共享内存。像这样，因为这门技术是“在写 入时进行复制”的，所以才被称为写时复制技术。

这样的话，GC 标记 - 清除算法就会存在一个问题 — 与写时复制技术不兼容。

## 多个空闲列表
之前我们讲的标记 - 清除算法中只用到了一个空闲链表，在这个空闲链表中，对大的分 块和小的分块进行同样的处理。
我们有一种方法，就是利用分块大小不同的空闲链表，即创建只连接大分块的空 闲链表和只连接小分块的空闲链表。
![](https://img-vnote-1251075307.cos.ap-beijing.myqcloud.com/1626191399_20210528141747023_449811881.png)

## BiBOP 法
将大小相近的对象整理成固定大小的块进行管理的做法。
GC 标记 - 清除算法中会发生碎片化。碎片化的原因之一就是堆上杂乱散布着大小各异的对象。
对此，我们可以用这个方法:把堆分割成固定大小的块，让每个块只能配置同样大小的 对象。这就是 BiBOP 法。

![](https://img-vnote-1251075307.cos.ap-beijing.myqcloud.com/1626191399_20210528141858910_845846527.png)

如图 2.10 所示，3 个字的对象被整合分配到左数第 1 个和第 3 个块，2 个字的对象被整 合分配到左数第 2 个块。像这样配置对象，就会提高内存的使用效率。因为每个块中只能配 置同样大小的对象，所以不可能出现大小不均的分块。
但是，使用 BiBOP 法并不能完全消除碎片化。比方说在全部用于 2 个字的块中，只有 1 到 2 个活动对象，这种情况下就不能算是有效利用了堆。

## 位图标记
> 为的是解决与`写时复制`不兼容

在单纯的 GC 标记 - 清除算法中，用于标记的位是被分配到各个对象的头中的。也就是说， 算法是把对象和头一并处理的。然而之前在 2.3.3 节中也提过，这跟写时复制技术不兼容。对此我们有个方法，那就是只收集各个对象的标志位并表格化，不跟对象一起管理。在 标记的时候，不在对象的头里置位，而是在这个表格中的特定场所置位。

![](https://img-vnote-1251075307.cos.ap-beijing.myqcloud.com/1626191400_20210528142119476_1948319796.png)

```
mark(obj) {
  obj_num = (obj - $heap_start) / WORD_LENGTH
  index = obj_num / WORD_LENGTH
  offset = obj_num % WORD_LENGTH

  if (($bitmap_tbl[index] &(1<<offset))==0) {
    $bitmap_tbl[index] |= (1<<offset)
    for(child: children(obj)) {
      mark(*child)
    }
  }
}
```

![](https://img-vnote-1251075307.cos.ap-beijing.myqcloud.com/1626229844_20210714101908818_1834650944.png)

> 这里相当于将内存所有地址空间抽象成一个二位数组，其每个内存地址都会映射到这个二维数组中的一个位置。这样对象被标记的信息就可以不在对象头上设置，而在这个二维数组上标记。

### 优点
- **与写时复制兼容**
    使用位图标记是不会对对象设置标志位的，所以也不会发生无谓的复制。
- **清除操作更有效**
    不仅在标记阶段，在清除阶段也可以得到好处。以往的清除操作都必须遍历整个堆，把
    非活动对象连接到空闲链表，同时取消活动对象的标志位。

    利用了位图表格的清除操作则把所有对象的标志位集合到一处，所以可以快速消去标志位。

### **要注意的地方**

在进行位图标记的过程中，有件事情我们必须注意，那就是对象地址和位图表格的对应。在堆有多个，对象地址不连续的情况下，我们无法用单纯的位运算求出标志位的 位置。因此，在堆为多个的情况下，一般会为每个堆都准备一个位图表格。
## 延迟清除法
清除所花费的时间是与堆的大小成正比的。也就是说，处理的堆越大，标记清除算法所花费的时间就越长，结果就会妨碍到mutator的处理。

延迟清除法(Lazy Sweep)是缩减因清除操作而导致的 mutator 最大暂停时间的方法。在 标记操作结束后，不一并进行清除操作，而是如其字面意思一样让它“延迟”，通过“延迟”来防止 mutator 长时间暂停。


---

## 总结

1. 标记清除算法分为 `标记` 和 `清除` 两个阶段
2. 标记清除算法容易产生 `碎片化` ，我们可以使用 `合并` 整理碎片化
3. 标记清除算法优点是： `实现简单`， `与保守式GC算法兼容`
4. 缺点是： `碎片化` ， `与写时复制不兼容` ， `分配速度问题`
5. 针对一个空闲链表造成的 `分配速度问题` ， 可以采用 `多个空闲链表` 
6. 针对 `碎片化` 问题，可以采用  `BiBOP 法` 进行优化，但仍无法彻底解决碎片化
7. 针对 `与写时复制不兼容` ， 可以使用 `位图标记` 进行优化。将标记信息从对象头部移到一个单独的位图表中