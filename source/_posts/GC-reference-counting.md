---
title: 「垃圾回收的算法与实现-引用计数算法」.md
date: 2021-07-14 11:32:33
tags: [GC, 垃圾回收, 引用计数]
categories:
- 技术博客
- 原创
---

## 引用计数的算法
引用计数法中，引入一个新的概念，`计数器` ，用以表示有多少程序引用了自己。

![](https://img-vnote-1251075307.cos.ap-beijing.myqcloud.com/1626276496_20210714113512690_404869287.png)

<!-- more -->

### 计数器的增减
在引用计数法中并没有 mutator 明确启动 GC 的语句。引用计数法与 mutator 的执行 密切相关，它在 mutator 的处理过程中通过增减计数器的值来进行内存管理。
这涉及到了 `new_obj()` 函数和 `update_ptr()` 函数。

### new_obj()
```javascript
new_obj(size) {
    obj = pickup_chunk(size, $free_list)

    if (obj == NULL) {
        allocation_fail()
    } else {
        obj.ref_cnt = 1
        return obj
    }
}
```

当pickup_chunk()函数返回NULL时分配就失败了。在引用计数法中，除了链接到空闲链表的对象，其他所有对象都是活动对象。也就是说，当pickup_chunk()函数返回NULL时，堆中就没有合适大小的分块了，分配就无法进行了。

### update_ptr()
```javascript
update_ptr(ptr, obj) {
    inc_ref_cnt(obj)
    dec_ref_cnt(*ptr)
    *ptr = obj
}

inc_ref_cnt(obj) {
    obj.ref_cnt++
}
dec_ref_cnt(obj) {
    obj.ref_cnt--
    if(obj.ref_cnt == 0) {
        for (child: children(obj)) {
            dec_ref_cnt(*child)
        }
        reclaim(obj)
    }
}
```
1. 对指针 ptr 新引用的对象(obj)的计数器进行增量操作
    - 这个操作很简单，只是对新引用的对象obj的计数器进行增量操作
2. 对指针 ptr 之前引用的对象(*ptr)的计数器进行减量操作
    - 首先对更新指针之前引用的对象 *ptr 的计数器进行减量操作。
    - 当计数器的值变为0时，该对象就变成了‘垃圾’，需要被回收
    - 递归调用其子对象，对所有子对象做减量操作
    - reclaim(obj)回收对象，即将该对象链接到空闲链表

下图为执行 `update_ptr(B,C)`后的状态示意图。
![](https://img-vnote-1251075307.cos.ap-beijing.myqcloud.com/1626276497_20210714183638492_1409912913.png)

在变更数组元素等的时候会进行指针的更新。通过更新指针，可能会产生没有被任何程序引用的垃圾对象。
**引用计数法中会监督在更新指针的时候是否有产生垃圾，从而在产生 垃圾时将其立刻回收**。也就是说，这意味着在分配时没有分块的情况下，堆中所有的对象都为活动对象，这时没法新分配对象。
另一方面，GC标记-清除算法即使产生了垃圾也不会将其马上回收，只会在没有分块的时候将垃圾一并回收。像这样，可以说将内存管理和 mutator 同时运行正是引用计数法的一大特征。


## 优点
### 可即可回收垃圾
在引用计数法中，每个对象始终都知道自己的被引用数(就是计数器的值)。当被引用数 的值为 0 时，对象马上就会把自己作为空闲空间连接到空闲链表。
各个对象在变 成垃圾的同时就会立刻被回收。
而在其他的 GC 算法中（比如标记-清除算法），即使对象变成了垃圾，程序也无法立刻判别。只有当 分块用尽后 GC 开始执行时，才能知道哪个对象是垃圾，哪个对象不是垃圾。
### 最大暂停时间短
在引用计数法中，只有当通过 mutator 更新指针时程序才会执行垃圾回收。 每次通过执行 mutator 生成垃圾时这部分垃圾都会被回收，因而大幅度地削减了 mutator 的最 大暂停时间。
### 没有必要沿指针查找
引用计数法和 GC 标记 - 清除算法不一样，没必要由根沿指针查找。

## 缺点
### 计数器值的增减处理繁重
在大多数情 况下指针都会频繁地更新。特别是有根的指针，会以近乎令人目眩的势头飞速地进行更新。 这是因为根可以通过 mutator 直接被引用。在引用计数法中，每当指针更新时，计数器的值都会随之更新，因此值的增减处理必然会变得繁重。
### 计数器需要占用很多位
用于引用计数的计数器最大必须能数完堆中所有对象的引用数。打个比方，假如我们用 的是 32 位机器，那么就有可能要让 2 的 32 次方个对象同时引用一个对象。考虑到这种情况， 就有必要确保各对象的计数器有 32 位大小。也就是说，对于所有对象，必须留有 32 位的空 间。这就害得内存空间的使用效率大大降低了。打比方说，假如对象只有 2 个域，那么其计 数器就占了它整体的 1/3。
### 实现繁琐复杂
引用计数的算法本身很简单，但事实上实现起来却不容易。
进行指针更新操作的 update_ptr() 函数是在 mutator 这边调用的。打个比方，我们需要 把以往写成 *ptr=obj 的地方都重写成 update_ptr(ptr,obj)。因为调用 update_ptr() 函 数的地方非常多，所以重写过程中很容易出现遗漏。如果漏掉了某处，内存管理就无法正确 进行，就会产生 BUG。
### 循环引用无法回收
> 这是最重要的一个缺点

```javascript
class Person{
    string name
    Person lover
}

ming = new Person('小明');
hong = new Person('小红')
ming.lover = hong
hong.lover = ming

ming = null
hong = null
```

上述伪代码表示情侣关系的两个人，小明和小红，他们之间相互引用，用完之后，都置为空。

![](https://img-vnote-1251075307.cos.ap-beijing.myqcloud.com/1626276497_20210714185152294_108465915.png)

因为两个对象互相引用，所以各对象的计数器的值都是1。但是这些对象组并没有被其他任何对象引用。因此想一并回收这两个对象都不行，只要它们的计数器值都是1，就无法回收。像这样在两个及两个以上的对象互相循环引用形成对象组的情况下，即使这些对象组都成了垃圾，程序也无法将它们回收。

## 延迟引用计数法
> 针对引用计数法中“计数器值的增减处理繁重”而提出的改进方法
如上所说，计数器值增减处理繁重的原因之一是从根的引用变化频繁。
因此，我们就让从根引用的指针的变化不反映在计数器上。打个比方，我们把重写**全局变量指针**的 `update_ptr($ptr,obj)` 改写成 `*$ptr = obj`。

但这样由于引用没有反映到计数器上，所以各个对象的计数器没有正确表示出对象本身的被引用数。

于是，我们在延迟引用计数法中使用ZCT（zero count table）。ZCT是一个表，事先记录下计数器值在 dec_ref_cnt() 函数的作用下变为 0 的对象。

![](https://img-vnote-1251075307.cos.ap-beijing.myqcloud.com/1626276498_20210714185851044_1920500749.png)

因为计数器值为 0 的对象不一定都是垃圾，所以暂时先将这些对象保留。我们必须修正 dec_ref_cnt() 函数，使其适应延迟引用计数法。

### dec_ref_cnt()


```javascript
dec_ref_cnt(obj) {
    obj.ref_cnt--
    if (obj.ref_cnt == 0) {
        if (is_full($zct) == TRUE) {
            scan_zct()
        }
        push($zct, obj)
    }
}
```

当 obj 的计数器值为 0(也就是说 obj 可能是垃圾)时，把 obj 添加到 $zct。不过， 如果 $zct 爆满，那么首先就要通过 scan_zct() 函数来减少 $zct 中的对象。

### new_obj()
我们也要稍微修正一下 new_obj() 函数。当无法分配大小合适的分块时，执行 scan_
zct() 函数。

```javascript
new_obj(size) {
    obj = pickup_chunk(size, $free_list)

    if (obj == NULL) {
        scan_zct()

        obj = pickup_chunk(size, $free_list)
        if (obj == NULL) {
            allocation_fail()
        }
    }

    obj.ref_cnt = 1
    return obj
}
```

如果第一次分配没有顺利进行，就意味着空闲链表中没有了大小合适的分块。此时程序 要搜索一遍 $zct，以再次分配分块。如果这样还不行，分配就失败了。

### scan_zct()

```javascript
scan_zct() {
    // 先对根上引用对象进行增量操作
    for (r: $roots) {
        (*r).ref_cnt++
    }

    // 扫描zct， 删除计数器为0的对象
    for(obj: $zct) {
        if (obj.ref_cnt == 0) {
            remove($zct, obj)
            delete(obj)
        }
    }

    // 再对根上引用对象进行减量操作
    for (r: $roots) {
        (*r).ref_cnt--
    }
}
```

如上涉及到的delete函数如下：
```javascript
delete(obj) {
    for (child: children(obj)) {
        (*child).ref_cnt--

        if ((*child).ref_cnt == 0) {
            delete(*child)
        }
    }

    reclaim(obj)
}
```

对 obj 的子对象的计数器进行减量操作，对计数器值变成 0 的对象执行 delete() 函数， 最后回收 obj。
最后把所有根引用的对象的计数器都进行减量操作。

### 优点
在延迟引用计数法中，程序延迟了根引用的计数，将垃圾一并回收。通过延迟，减轻了
因根引用频繁发生变化而导致的计数器增减所带来的额外负担。
### 缺点
为了延迟计数器值的增减，垃圾不能马上得到回收，这样一来垃圾就会压迫堆，我们也就失去了引用计数法的一大优点 — 可即刻回收垃圾。
另外，scan_zct() 函数导致最大暂停时间延长了。执行 scan_zct() 函数所花费的时间 与 $zct 的大小成正比。$zct 越大，要搜索的对象就越多，妨碍 mutator 运作的时间也就越长。 要想缩减因 scan_zct() 函数而导致的暂停时间，就要缩小 $zct。但是这样一来调用 scan_ zct() 函数的频率就增加了，也压低了吞吐量。很明显这样就本末倒置了。

## sticky引用计数法
在引用计数法中有提到，计数器需要占用很多位。
假设为了反映所有引用，计数器需要一个字（32位机器就是32位）的空间。这样会消耗大量的内存空间。

针对这个缺点，我们可以使用 减少计数器位宽的“sticky引用计数法”。

举个例子，我们假设用于计数器位宽的位数为5，那么这种计数器只能记录31个引用数。如果对象被大于31个对象引用，就会出现计数器溢出。

对于计数器溢出，我们有两种方法来处理：

### 什么都不做
对于计数器溢出的对象，我们可以这样处理:不再增减计数器的值，就把它放着，什么也不做。不过这样一来，即使这个对象成了垃圾(即被引用数为 0)，也不能将其回收。也就是说， 白白浪费了内存空间。
> 什么都不做，就会导致这些计数器溢出的对象的计数器永远不会发生变化。但对象的实际引用关系可能随时在变的，有可能实际的引用关系会变成0，此时该对象也就成了垃圾，但由于计数器不发生变化，所以，这里的垃圾永远也不会被回收。

很多研究表明，很多对象一旦生成会立马死掉。也就是说，大多数情况下，对象的计数器值会在0和1的范围内变化，鲜少出现5位计数器溢出的情况。

而且，计数器溢出的对象在执行的程序中占有非常重要的位置，所以其将来称为垃圾的可能性极低。

就以上两个假设，不增减计数器的值，就这么放着，也不会有太大的问题。


### 使用标记-清除算法进行管理
另一个方法是，在适当的时机用标记-清除算法来充当引用计数法的后援。但这里的标记-清除算法要和以往的不同。

```javascript
mark_sweep_for_counter_overflow(){
 reset_all_ref_cnt()         // 将所有对象计数器都置为0
 mark_phase()                // 标记阶段
 sweep_phase()              // 清除阶段
}

// 标记
mark_phase() {
    for (r: $roots) {
        push(*r, $mark_stack)
    }

    while(is_empty($mark_stack) == FALSE) {
        obj = pop($mark_stack)
        obj.ref_cnt++
        if (obj.ref_cnt == 1) {
            for(child: children(obj)) {
                push(*child, $mark_stack)
            }
        }
    }
}

// 清除
sweep_phase() {
    sweeping = $heap_top
    while(sweeping < $head_end) {
        if (sweeping.ref_cnt == 0) {
            reclaim(sweeping)
        }

        sweeping += sweeping.size
    }
}
```

在标记阶段，首先把由根直接引用的对象堆到标记栈里，然后按顺序从标记栈取出对象， 对计数器进行增量操作。不过，这里必须只把各个对象及其子对象堆进标记栈一次。在第 8 行会检查各个对象是不是只堆进去了一次。一旦栈为空，则标记阶段结束。

> 这里标记的不是TRUE或FALSE，而是对象被引用的次数。
> 在这里，所有对象的计数器不会超过2.因为当计数器为2时，说明该对象已被标记过1次，即该对象至少被其他对象引用过一次，这里就没必要在增加计数器了。因为我们只要保证这个对象说明是活动的，不是垃圾，不会被回收即可

在清除阶段，程序会搜索整个堆，回收计数器值仍为 0 的对象。

我们在这里介绍的 GC 标记 - 清除算法和在第 2 章中介绍的 GC 标记 - 清除算法主要有 以下 3 点不同。

1. 一开始就把所有对象的计数器值设为 0
2. 不标记对象，而是对计数器进行增量操作
3. 为了对计数器进行增量操作，算法对活动对象进行了不止一次的搜索

像这样，只要把引用计数法和 GC 标记 - 清除算法结合起来，在计数器溢出后即使对象成了垃圾，程序还是能回收它。另外还有一个优点，那就是还能回收循环的垃圾。
但是在进行标记处理之前，必须重置所有的对象和计数器。此外，因为在查找对象时没有设置标志位而是把计数器进行增量，所以需要多次(次数和被引用数一致)查找活动对象。 考虑到这一点的话，显然在这里进行的标记处理比以往的 GC 标记 - 清除算法中的标记处理要花更多的时间。也就是说，吞吐量会相应缩小。

> 如上所说，相较于普通的标记-清除法，在标记处理要查找更多次，需要花的时间更多，导致吞吐量缩小。
> 个人没明白相较于普通的标记-清除法有何优势。
> 如果非要找的话，就是在采用了引用计数法的GC里，它可以减少计数器占用很多位，而且也解决了引用计数法中循环引用无法回收的缺点。


## 1位引用计数法
1位引用计数法是sticky引用计数法的一个极端例子。计数器只有1位。

即使计数器只有 1 位，通过用 0 表示被引用数为 1， 用 1 表示被引用数大于等于 2，这样也能有效率地进行内存管理。使用 1 位计数器时各对象 的处理方法如图 3.7 所示。

![](https://img-vnote-1251075307.cos.ap-beijing.myqcloud.com/1626276498_20210714232646884_1176874033.png)

## 总结
- 引用计数法中有一个计数器，用以标识有多少程序引用自己。
- 引用计数法中会监督在更新指针的时候是否有产生垃圾，从而在产生 垃圾时将其立刻回收。
- 引用计数法的优点：可即可回收垃圾， 最大暂停时间短， 没有必要沿指针查找
- 引用计数法的缺点： 计数器值的增减处理繁重， 计数器需要占用很多位， 实现繁琐复杂， 循环引用无法回收
- 针对计数器值的增减处理繁重，有一个延迟引用计数法可以优化。减轻了因根引用频繁发生变化而导致的计数器增减所带来的额外负担，但这样一来就失去了可即可回收垃圾这个优点，并且导致最大暂停时长延长了。
- 针对计数器需要占用很多位这个缺点，减少计数器位宽sticky引用计数法可以优化。但同时要处理计数器溢出的情况。计数器溢出，可以什么都不做，或者采用标记-清除算法，同时也解决了循环引用无法回收这个缺点。
- 1位引用计数法