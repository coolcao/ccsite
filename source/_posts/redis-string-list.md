---
title: Redis数据结构内部实现-字符串，链表
date: 2019-12-03 22:04:28
tags: [redis, 数据结构]
categories:
- 笔记
- Redis
---

Redis是一款简单快速的内存数据库，常被用作缓存数据库。
其内部的数据结构的实现，也是非常的精彩，因此学习了解其数据结构的内部实现也是非常有用的。
<!--more-->

# 字符串SDS

Redis的字符串结构，并没有直接使用C语言的字符串实现（以空字符结尾的字符数组），而是构建了一套名为简单动态字符串（SDS）的结构，并将SDS用作Redis的默认字符串表示。


## Redis中SDS的定义：

```c
struct sdshdr {
    // 记录buf数组中已使用的字节数量，等于字符串长度
    int len;
    // 记录buf数组中未使用的字节数量
    int free;
    // 字节数组，用于保存字符串
    char buf[];
}
```

![sds结构](https://img001-10042971.cos.ap-shanghai.myqcloud.com/blog/sds.png)

如图展示了一个SDS的示例，其中free为0，表示这个SDS已经没有未分配的字符，len为5表示SDS长度为5，buf为一个字符数组，和C语言中的字符串表示是一致的，以空字符`\0`结尾。

SDS这种结构，相对于C语言的字符串有什么优势呢？

## SDS特点

其一就是，**可以在常数复杂度O(1)获取字符串长度**。C语言中，由于没有额外记录字符串长度，在获取字符串长度时，都要遍历整个字符数组才能计算长度，复杂度为O(n)。而Redis的SDS可以直接从len属性即可获取整个字符串的长度。因为Redis毕竟是内存数据库，这样保证即使是计算非常长的字符串长度时，不会成为性能瓶颈。

其二就是，**杜绝缓冲区溢出**。还是和上面原因类似，由于C语言没有额外记录字符串长度，因此在做两个字符串的拼接时，要求程序员在拼接字符串时要为字符串分配足够长度的内存，否则会发生溢出。而SDS则没有C字符串的这种情况，当SDS API需要对SDS修改时，API会先检查SDS的空间是否满足修改需求，如果不满足，API会自动将SDS空间拓展至执行修改所需的大小，然后再执行修改操作，所以，SDS既不需要手动修改SDS空间大小，也不会出现缓冲区溢出的情况。

另外就是，**减少修改字符串时带来的内存重分配次数**。这个优势，也很好理解了。修改C语言的字符串时，不管还增长还是缩减字符串长度操作，都需要程序员重新分配内存，以避免出现溢出或者内存泄漏的发生。而对于SDS，由于其会记录free未使用字符长度，因此，在一定程度上会减少重新分配内存次数。

通过未使用空间free，SDS实现了*空间预分配*和*惰性空间释放*两种优化策略来减少内存重新分配。

再有就是，**二进制安全**。这个怎么理解呢？C语言的字符串最后一个字符采用空字符`\0`来标识字符串的结束，因此只能存储文本数据，也就是纯字符串形式，不能保存图片，音频视频等二进制数据。而SDS虽然也是使用字符数组来保存数据，但是其使用len属性来记录字符串的长度，因此不依赖于空字符标识字符串结尾，因此可以保存其他二进制数据。通过使用二进制安全的SDS，而不是C的字符串，Redis不仅可以保存文本数据，还能保存任意格式的二进制数据。

虽然实现上不同于C的字符串，但是SDS却**兼容部分C字符串函数**。因为buf也是字符数组来保存数据，因此可以直接使用C的部分字符串函数，这样Redis就不用再专门写函数来操作SDS了，能复用C函数的直接复用，不能复用的再专门重写函数。

## C字符串和SDS的一些区别：

|C字符串|SDS|
|----|----|
|获取字符串长度复杂度O(n)|获取字符串长度复杂度O(1)|
|API是不安全的，可能会造成缓冲区溢出|API是安全的，不会造成缓冲区溢出|
|修改字符串长度N次必然需要执行N次内存分配|修改字符串长度N次最多需要执行N次内存分配|
|只能保存文本数据|可以保存文本或二进制数据|
|可以使用所有<string.h>库中的函数|可以使用部分<string.h>库中的函数|

# 链表
链表在Redis中的应用非常广泛，比如列表键的底层实现之一就是链表。除了链表键之外，发布与订阅，慢查询，监视器等功能也也用到了链表，Redis服务器本身还使用链表来保存多个客户端的状态信息，以及使用链表来构建客户端输出缓冲区。

## 链表的实现：

```c
typedef struct listNode {
    struct listNode *prev;
    struct listNode *next;
    void *value;
} listNode
```

![list](https://img001-10042971.cos.ap-shanghai.myqcloud.com/blog/list.png)

上面是链表节点的定义，可以直接使用多个节点来组成一个链表，但是Redis又实现了一个list结构来操作链表：

```c
typedef struct list {
    // 头节点
    listNode *head;
    // 尾节点
    listNode *tail;
    // 链表包含节点数量
    unsigned long len;
    // 节点值复制函数
    void *(*dup) (void *ptr);
    // 节点值释放函数
    void *(*free) (void *ptr);
    // 节点值对比函数
    int (*match) (void *ptr, void *key);
}list;
```

list结构为链表提供了表头指针head，表尾指针tail，以及链表长度len。而dup,free和match则是用于实现多态链表所需的特定函数：

* dup 用于复制链表节点所保存的值
* free 用于释放链表节点所保存的值
* match 用于对比链表节点所保存的值和另一个输入值是否相等。

![list](https://img001-10042971.cos.ap-shanghai.myqcloud.com/blog/list2.png)

## Redis的链表特性：

1. 双端：链表节点都有prev和next指针，获取某个节点的前置节点和后置节点的复杂度都是O(1)
2. 无环：表头节点的prev指针和表尾节点的next指针都指向NULL，对链表的访问以NULL为终点
3. 带表头指针和表尾指针：通过list结构的head指针和tail指针，程序获取链表表头节点和表尾节点的复杂度为O(1)
4. 带链表长度计数器：程序使用list结构的len属性来对list持有的链表节点进行计数，获取链表中节点个数的复杂度为O(1)
5. 多态：链表使用void*指针来保存节点值，并且可以通过list结构的dup,free,match三个函数为节点值设置类型特定函数，所以链表可以用于保存各种不同类型的值。

