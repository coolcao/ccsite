---
title: [学习笔记]你不知道的js-词法作用域
date: 2016-11-13 20:14:51
tags: [js]
categories:
- 学习笔记
- 你不知道的js
---

## 词法阶段
简单的说，词法作用域就是定义在词法阶段的作用域。换句话说，词法作用域是由你在写代码时将变量和块作用域写在哪里来决定的，因此当词法分析器处理代码时会保持作用域不变。（大部分情况是这样）

### 查找
作用域查找会在找到第一个匹配的标识符时停止。
在多层的嵌套作用域中可以定义同名的标识符，这叫做“遮蔽效应”（内部的标识符遮蔽了外部的标识符）。
全局变量会自动称为全局对象的属性，因此可以不直接通过全局对象的词法名称，而是间接的通过对全局对象属性的引用来对其进行访问。
`window.a`
通过这种技术可以访问那些被同名变量所遮蔽的全局变量。但非全局变量如果被遮蔽了，无论如何都无法被访问到。
无论函数在哪里被调用，也无论它如何被调用，它的词法作用域都只由函数被声明时所处的位置决定。

## 欺骗词法
### eval
Javascript中的eval()函数可以接受一个字符串为参数，并将其中的内容视为好像在书写时就存在与程序这个位置的代码。
```js
function foo(str,a){
  eval(str);  //欺骗
  console.log(a,b);
}
var b = 2;
foo('var b = 3;',1);  //1,3
```

eval()调用中的`var b = 3;`这段代码会被当作本来就在那里的一样处理。由于代码声明了一个新的变量b，因此它对已存在的foo()的词法作用域进行了修改。
当console.log()被执行时，会在foo()的内部同时找到a和b，但永远也无法找到外部的b，因此会输出1,3，而不是正常情况下的1,2.
> 在严格模式的程序中，eval()在运行时有其自己的词法作用域，意味着其中的声明无法修改所在的作用域。
```js
function foo(str){
  'use strict';
  eval(str);
  console.log(a); //ReferenceError:a is not defined
}
foo('var a = 2;');
```
*在程序中动态生成代码的使用场景非常罕见，因为它所带来的好处无法抵消性能上的损失。*

### with
Javascript中另一个难以掌握（并且现在也不推荐使用）的用来欺骗词法作用域的功能是with关键字。
with通常被当作重复引用同一个对象中的多个属性的快捷方式，可以不需要重复引用对象本身。
但实际上这不仅仅是为了方便的访问对象属性。考虑如下代码：
```js
function foo(obj){
  with(obj){
    a = 2;
  }
}

var o1 = {
  a:3
}
var o2 = {
  b:3
}
foo(o1);
console.log(o1.a);
foo(o2);
console.log(o2.a);  //undefined
console.log(a);     //2,a被泄漏到全局作用域上了
```
*with可以将一个没有或有多个属性的对象处理为一个完全隔离的词法作用域，因此这个对象的属性也会被处理为定义在这个作用域中的词法标识符。*
> 尽管with块可以将一个对象处理为词法作用域，但是这个块内部的var声明并不会被限制在这个块的作用域中，而是被添加到with所处的函数作用域中。
**另一个不推荐使用eval()和with的原因是，会被严格模式所影响。with被完全禁止，而在保留核心功能的前提下间接或非安全的使用eval()也被禁止了。**

### 性能
如果代码中大量使用eval()或with，那么运行起来一定会变得非常慢。无论引擎多聪明，试图将这些悲观情况的副作用限制在最小范围内，也无法避免如果没有这些优化，代码会变得更慢的这个事实。

## 小结
词法作用域意味着作用域是由书写代码时函数声明的位置决定的。
Javascript中有两个机制可以“欺骗”词法作用域：eval()和with。前者可以对一段包含一个或多个声明的代码字符串进行演算，并借此来修改已经存在的词法作用域（在运行时）。后者本质上是通过将一个对象的引用当作作用域来处理，将对象的属性当作作用域中的标识符来处理，从而创建了一个新的词法作用域（同样是在运行时）。
这两个机制的副作用是引擎无法在编译时对作用域查找进行优化，因为引擎谨慎的认为这样的优化是无效的。使用这其中的任何一个机制都将导致代码运行缓慢。**不要使用它们。**
