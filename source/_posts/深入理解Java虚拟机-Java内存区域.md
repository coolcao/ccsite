---
title: 深入理解Java虚拟机-Java内存区域.md
date: 2021-07-21 22:37:55
tags: [深入理解Java虚拟机]
categories:
- 技术博客
- 笔记
---

## Java运行时数据区域

![1161857-20200420103402016-1117353618](https://img-vnote-1251075307.cos.ap-beijing.myqcloud.com/1626881874_20210721224745709_1993848410.png)

### 程序计数器

程序计数器是一块较小的内存区域，它可以看作是当前线程所执行的字节码的行号指示器。
在Java虚拟机的概念模型里，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。它是程序控制流的指示器，分支，循环，跳转，异常处理，线程恢复等基础功能都需要依赖这个计数器来完成。

为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间计数器互不影响，独立存储，我们称这类内存区域为**线程私有**的内存。


### Java虚拟机栈

与计数器一样，Java虚拟机栈也是线程私有的。

虚拟机栈描述的是Java方法执行的线程内存模型：每个方法被执行的时候，Java虚拟机都会同步创建一个栈帧用于存储局部变量表，操作数栈，动态连接，方法出口等信息。

局部变量表中存储了编译期可知的各种Java虚拟机基本数据类型（boolean, byte, char, short, int, float, long, double）,对象引用和returnAddress类型（指向了一条字节码指令的地址）。


### 本地方法栈
本地方法栈与虚拟机栈所发挥的作用是非常相似的，区别在于，虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机用到本地（Native）方法服务。

### Java堆
对于Java应用程序来说，Java堆（Heap）是虚拟机所管理的内存中最大的一块。

Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是**存放Java对象实例**。Java 世界里“几乎”所有的对象实例都是在这里分配内存。

### 方法区
方法区与堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类型信息，常量，静态变量，即时编译器编译后的代码缓存等数据。

### 运行时常量池
运行时常量池是方法区的一部分。Class文件中除了有类的版本，字段， 方法，接口等描述信息外，还有一项信息是常量池，用于存放编译期生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。

## HotSpot虚拟机对象探秘
### 对象的创建
当Java虚拟机遇到一条字节码`new`指令时，首先将去检查这个指令的参数是否在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载，解析和初始化过。如果没有，那必须先执行相应的类加载过程。

在类加载通过后，接下来虚拟机将为新生对象分配内存。

分配内存有两种方式：

- 指针碰撞：
    - 堆中内存是规整的，所有被使用过的内存在一边，空闲的内存在另一边，中间有指针作为分界点的指示器。分配内存时仅仅是把那个指针向空闲空间方向挪动一段与对象大小相等的距离。
- 空闲列表
    - 堆中的内存不是规整的，已使用的内存和空闲内存相互交错在一起，分配内存时虚拟机必须维护一个列表，记录哪些内存块是可用的，分配时从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录。

当使用带有空间压缩整理过程的收集器时，系统采用的分配算法是指针碰撞，既简单又高效。
当使用基于清除算法的收集器时，理论上只能采用较复杂的空闲列表来分配内存。

解决创建对象时在并法情况下的线程安全问题有两种可选方案：

1. 对分配内存的动作进行同步处理。实际上虚拟机时采用CAS配上失败重试的方式保证更新操作的原子性。
2. 把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存，成为本地线程分配缓冲（TLAB）。虚拟机是否启用TLAB可以通过参数`-XX:+/-UserTLAB`来设定。

分配完内存后，Java 虚拟机还要对对象进行必要的设置。

上面的工作都完成后，从虚拟机的角度来说，一个新的对象已经产生了。

### 对象的内存分布
在HotSpot虚拟机里，对象在堆内存中的存储布局可以划分为三个部分：对象头， 实例数据， 对齐填充。

对象头包括两类信息：

1. 用于存储对象自身的运行时数据，如哈希码，GC 分代年龄，锁状态标志，线程持有的锁，偏向线程ID，偏向时间戳等。
2. 类型指针，即对象指向它的类型元素的指针。Java虚拟机通过这个指针来确定该对象是哪个类的实例。此外，如果对象是一个Java数组，那在对象头中还必须有一块用于记录数组长度的数据。

实例数据部分是对象真正存储的有效信息，即我们在程序代码里所定义的各种字段内容，无论时从父类继承下来的还是在子类中定义的字段，都必须记录起来。

对象的第三部分是对齐填充。由于HotSpot虚拟机的自动内存管理系统要求对象起始地址必须是8字节的整数倍，对象头已经被设计成正好是8字节的整数倍（1倍或2倍），因此，如果实例数据部分没有对齐的话，就需要通过对齐填充来补全。

### 对象的访问定位
主流的访问方式有两种：

![wpid-dcdfb554be82428073f802d4628207d9_0](https://img-vnote-1251075307.cos.ap-beijing.myqcloud.com/1626882090_20210721234008631_1281991511.png)
通过句柄访问对象


![wpid-dcdfb554be82428073f802d4628207d9_0](https://img-vnote-1251075307.cos.ap-beijing.myqcloud.com/1626882090_20210721234018032_1123455529.png)
通过直接指针访问对象

1. 句柄访问
    1. Java堆中可能会划分出一块内存作为句柄池，reference中存储的是对象的句柄地址，而句柄中包含了对象实例数据和类型数据各自具体的地址信息
    2. 使用句柄的好处是，由于reference存储的是句柄地址，在对象被移动（垃圾回收时对象被移动是非常普遍的行为）时只会改变句柄中的实例数据指针，而reference本身不需要修改。
2. 直接指针访问
    1. reference中存储的直接就是对象的地址，如果只是访问对象本身的话，就不需要多一次间接访问的开销。
    2. 使用直接指针访问最大的好处就是速度更快，它节省了一次指针定位的时间开销，由于对象访问在Java中非常频繁，因此这类开销积少成多也是一项极为可观的执行成本。

HotSpot虚拟机主要使用第二种方式进行对象访问。
